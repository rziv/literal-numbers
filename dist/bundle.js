/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./test/literalNumbers.spec.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/assert/assert.js?");

/***/ }),

/***/ "./node_modules/balanced-match/index.js":
/*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\n\n//# sourceURL=webpack:///./node_modules/balanced-match/index.js?");

/***/ }),

/***/ "./node_modules/brace-expansion/index.js":
/*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var concatMap = __webpack_require__(/*! concat-map */ \"./node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"./node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/brace-expansion/index.js?");

/***/ }),

/***/ "./node_modules/concat-map/index.js":
/*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/concat-map/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/fs.realpath/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs.realpath/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\")\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = __webpack_require__(/*! ./old.js */ \"./node_modules/fs.realpath/old.js\")\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/fs.realpath/index.js?");

/***/ }),

/***/ "./node_modules/fs.realpath/old.js":
/*!*****************************************!*\
  !*** ./node_modules/fs.realpath/old.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\nvar isWindows = process.platform === 'win32';\nvar fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\");\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/fs.realpath/old.js?");

/***/ }),

/***/ "./node_modules/glob/common.js":
/*!*************************************!*\
  !*** ./node_modules/glob/common.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/glob/common.js?");

/***/ }),

/***/ "./node_modules/glob/glob.js":
/*!***********************************!*\
  !*** ./node_modules/glob/glob.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\")\nvar rp = __webpack_require__(/*! fs.realpath */ \"./node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\nvar assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\")\nvar globSync = __webpack_require__(/*! ./sync.js */ \"./node_modules/glob/sync.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"./node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(/*! inflight */ \"./node_modules/inflight/inflight.js\")\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\")\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\")\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/glob/glob.js?");

/***/ }),

/***/ "./node_modules/glob/sync.js":
/*!***********************************!*\
  !*** ./node_modules/glob/sync.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\")\nvar rp = __webpack_require__(/*! fs.realpath */ \"./node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar Glob = __webpack_require__(/*! ./glob.js */ \"./node_modules/glob/glob.js\").Glob\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\")\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\nvar assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"./node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/glob/sync.js?");

/***/ }),

/***/ "./node_modules/inflight/inflight.js":
/*!*******************************************!*\
  !*** ./node_modules/inflight/inflight.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\")\nvar reqs = Object.create(null)\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\")\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/inflight/inflight.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core.js":
/*!*******************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports = __webpack_require__(/*! ./jasmine-core/jasmine.js */ \"./node_modules/jasmine-core/lib/jasmine-core/jasmine.js\");\nmodule.exports.boot = __webpack_require__(/*! ./jasmine-core/node_boot.js */ \"./node_modules/jasmine-core/lib/jasmine-core/node_boot.js\");\n\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\"),\n    fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\");\n\nvar rootPath = path.join(__dirname, \"jasmine-core\"),\n    bootFiles = ['boot.js'],\n    nodeBootFiles = ['node_boot.js'],\n    cssFiles = [],\n    jsFiles = [],\n    jsFilesToSkip = ['jasmine.js'].concat(bootFiles, nodeBootFiles);\n\nfs.readdirSync(rootPath).forEach(function(file) {\n  if(fs.statSync(path.join(rootPath, file)).isFile()) {\n    switch(path.extname(file)) {\n      case '.css':\n        cssFiles.push(file);\n      break;\n      case '.js':\n        if (jsFilesToSkip.indexOf(file) < 0) {\n        jsFiles.push(file);\n      }\n      break;\n    }\n  }\n});\n\nmodule.exports.files = {\n  path: rootPath,\n  bootDir: rootPath,\n  bootFiles: bootFiles,\n  nodeBootFiles: nodeBootFiles,\n  cssFiles: cssFiles,\n  jsFiles: ['jasmine.js'].concat(jsFiles),\n  imagesDir: path.join(__dirname, '../images')\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./node_modules/jasmine-core/lib/jasmine-core.js?");

/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/jasmine.js":
/*!***************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/jasmine.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {/*\nCopyright (c) 2008-2018 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar getJasmineRequireObj = (function (jasmineGlobal) {\n  var jasmineRequire;\n\n  if (typeof module !== 'undefined' && module.exports && typeof exports !== 'undefined') {\n    if (typeof global !== 'undefined') {\n      jasmineGlobal = global;\n    } else {\n      jasmineGlobal = {};\n    }\n    jasmineRequire = exports;\n  } else {\n    if (typeof window !== 'undefined' && typeof window.toString === 'function' && window.toString() === '[object GjsGlobal]') {\n      jasmineGlobal = window;\n    }\n    jasmineRequire = jasmineGlobal.jasmineRequire = {};\n  }\n\n  function getJasmineRequire() {\n    return jasmineRequire;\n  }\n\n  getJasmineRequire().core = function(jRequire) {\n    var j$ = {};\n\n    jRequire.base(j$, jasmineGlobal);\n    j$.util = jRequire.util(j$);\n    j$.errors = jRequire.errors();\n    j$.formatErrorMsg = jRequire.formatErrorMsg();\n    j$.Any = jRequire.Any(j$);\n    j$.Anything = jRequire.Anything(j$);\n    j$.CallTracker = jRequire.CallTracker(j$);\n    j$.MockDate = jRequire.MockDate();\n    j$.getClearStack = jRequire.clearStack(j$);\n    j$.Clock = jRequire.Clock();\n    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler(j$);\n    j$.Env = jRequire.Env(j$);\n    j$.StackTrace = jRequire.StackTrace(j$);\n    j$.ExceptionFormatter = jRequire.ExceptionFormatter(j$);\n    j$.Expectation = jRequire.Expectation();\n    j$.buildExpectationResult = jRequire.buildExpectationResult();\n    j$.JsApiReporter = jRequire.JsApiReporter();\n    j$.matchersUtil = jRequire.matchersUtil(j$);\n    j$.ObjectContaining = jRequire.ObjectContaining(j$);\n    j$.ArrayContaining = jRequire.ArrayContaining(j$);\n    j$.ArrayWithExactContents = jRequire.ArrayWithExactContents(j$);\n    j$.pp = jRequire.pp(j$);\n    j$.QueueRunner = jRequire.QueueRunner(j$);\n    j$.ReportDispatcher = jRequire.ReportDispatcher(j$);\n    j$.Spec = jRequire.Spec(j$);\n    j$.Spy = jRequire.Spy(j$);\n    j$.SpyFactory = jRequire.SpyFactory(j$);\n    j$.SpyRegistry = jRequire.SpyRegistry(j$);\n    j$.SpyStrategy = jRequire.SpyStrategy(j$);\n    j$.StringMatching = jRequire.StringMatching(j$);\n    j$.UserContext = jRequire.UserContext(j$);\n    j$.Suite = jRequire.Suite(j$);\n    j$.Timer = jRequire.Timer();\n    j$.TreeProcessor = jRequire.TreeProcessor();\n    j$.version = jRequire.version();\n    j$.Order = jRequire.Order();\n    j$.DiffBuilder = jRequire.DiffBuilder(j$);\n    j$.NullDiffBuilder = jRequire.NullDiffBuilder(j$);\n    j$.ObjectPath = jRequire.ObjectPath(j$);\n    j$.GlobalErrors = jRequire.GlobalErrors(j$);\n\n    j$.Truthy = jRequire.Truthy(j$);\n    j$.Falsy = jRequire.Falsy(j$);\n    j$.Empty = jRequire.Empty(j$);\n    j$.NotEmpty = jRequire.NotEmpty(j$);\n\n    j$.matchers = jRequire.requireMatchers(jRequire, j$);\n\n    return j$;\n  };\n\n  return getJasmineRequire;\n})(this);\n\ngetJasmineRequireObj().requireMatchers = function(jRequire, j$) {\n  var availableMatchers = [\n      'nothing',\n      'toBe',\n      'toBeCloseTo',\n      'toBeDefined',\n      'toBeFalsy',\n      'toBeGreaterThan',\n      'toBeGreaterThanOrEqual',\n      'toBeLessThan',\n      'toBeLessThanOrEqual',\n      'toBeNaN',\n      'toBeNegativeInfinity',\n      'toBeNull',\n      'toBePositiveInfinity',\n      'toBeTruthy',\n      'toBeUndefined',\n      'toContain',\n      'toEqual',\n      'toHaveBeenCalled',\n      'toHaveBeenCalledBefore',\n      'toHaveBeenCalledTimes',\n      'toHaveBeenCalledWith',\n      'toHaveClass',\n      'toMatch',\n      'toThrow',\n      'toThrowError',\n      'toThrowMatching',\n    ],\n    matchers = {};\n\n  for (var i = 0; i < availableMatchers.length; i++) {\n    var name = availableMatchers[i];\n    matchers[name] = jRequire[name](j$);\n  }\n\n  return matchers;\n};\n\ngetJasmineRequireObj().base = function(j$, jasmineGlobal) {\n  j$.unimplementedMethod_ = function() {\n    throw new Error('unimplemented method');\n  };\n\n  /**\n   * Maximum object depth the pretty printer will print to.\n   * Set this to a lower value to speed up pretty printing if you have large objects.\n   * @name jasmine.MAX_PRETTY_PRINT_DEPTH\n   */\n  j$.MAX_PRETTY_PRINT_DEPTH = 8;\n  /**\n   * Maximum number of array elements to display when pretty printing objects.\n   * This will also limit the number of keys and values displayed for an object.\n   * Elements past this number will be ellipised.\n   * @name jasmine.MAX_PRETTY_PRINT_ARRAY_LENGTH\n   */\n  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 50;\n  /**\n   * Maximum number of charasters to display when pretty printing objects.\n   * Characters past this number will be ellipised.\n   * @name jasmine.MAX_PRETTY_PRINT_CHARS\n   */\n  j$.MAX_PRETTY_PRINT_CHARS = 1000;\n  /**\n   * Default number of milliseconds Jasmine will wait for an asynchronous spec to complete.\n   * @name jasmine.DEFAULT_TIMEOUT_INTERVAL\n   */\n  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;\n\n  j$.getGlobal = function() {\n    return jasmineGlobal;\n  };\n\n  /**\n   * Get the currently booted Jasmine Environment.\n   *\n   * @name jasmine.getEnv\n   * @function\n   * @return {Env}\n   */\n  j$.getEnv = function(options) {\n    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);\n    //jasmine. singletons in here (setTimeout blah blah).\n    return env;\n  };\n\n  j$.isArray_ = function(value) {\n    return j$.isA_('Array', value);\n  };\n\n  j$.isObject_ = function(value) {\n    return !j$.util.isUndefined(value) && value !== null && j$.isA_('Object', value);\n  };\n\n  j$.isString_ = function(value) {\n    return j$.isA_('String', value);\n  };\n\n  j$.isNumber_ = function(value) {\n    return j$.isA_('Number', value);\n  };\n\n  j$.isFunction_ = function(value) {\n    return j$.isA_('Function', value);\n  };\n\n  j$.isAsyncFunction_ = function(value) {\n    return j$.isA_('AsyncFunction', value);\n  };\n\n  j$.isTypedArray_ = function(value) {\n    return j$.isA_('Float32Array', value) ||\n      j$.isA_('Float64Array', value) ||\n      j$.isA_('Int16Array', value) ||\n      j$.isA_('Int32Array', value) ||\n      j$.isA_('Int8Array', value) ||\n      j$.isA_('Uint16Array', value) ||\n      j$.isA_('Uint32Array', value) ||\n      j$.isA_('Uint8Array', value) ||\n      j$.isA_('Uint8ClampedArray', value);\n  };\n\n  j$.isA_ = function(typeName, value) {\n    return j$.getType_(value) === '[object ' + typeName + ']';\n  };\n\n  j$.isError_ = function(value) {\n    if (value instanceof Error) {\n      return true;\n    }\n    if (value && value.constructor && value.constructor.constructor &&\n      (value instanceof (value.constructor.constructor('return this')()).Error)) {\n      return true;\n    }\n    return false;\n  };\n\n  j$.getType_ = function(value) {\n    return Object.prototype.toString.apply(value);\n  };\n\n  j$.isDomNode = function(obj) {\n    return obj.nodeType > 0;\n  };\n\n  j$.isMap = function(obj) {\n    return typeof jasmineGlobal.Map !== 'undefined' && obj.constructor === jasmineGlobal.Map;\n  };\n\n  j$.isSet = function(obj) {\n    return typeof jasmineGlobal.Set !== 'undefined' && obj.constructor === jasmineGlobal.Set;\n  };\n\n  j$.isPromise = function(obj) {\n    return typeof jasmineGlobal.Promise !== 'undefined' && obj.constructor === jasmineGlobal.Promise;\n  };\n\n  j$.fnNameFor = function(func) {\n    if (func.name) {\n      return func.name;\n    }\n\n    var matches = func.toString().match(/^\\s*function\\s*(\\w+)\\s*\\(/) ||\n      func.toString().match(/^\\s*\\[object\\s*(\\w+)Constructor\\]/);\n\n    return matches ? matches[1] : '<anonymous>';\n  };\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value being compared is an instance of the specified class/constructor.\n   * @name jasmine.any\n   * @function\n   * @param {Constructor} clazz - The constructor to check against.\n   */\n  j$.any = function(clazz) {\n    return new j$.Any(clazz);\n  };\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value being compared is not `null` and not `undefined`.\n   * @name jasmine.anything\n   * @function\n   */\n  j$.anything = function() {\n    return new j$.Anything();\n  };\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value being compared is `true` or anything truthy.\n   * @name jasmine.truthy\n   * @function\n   */\n  j$.truthy = function() {return new j$.Truthy();};\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value being compared is  `null`, `undefined`, `0`, `false` or anything falsey.\n   * @name jasmine.falsy\n   * @function\n   */\n  j$.falsy = function() {return new j$.Falsy();};\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value being compared is empty.\n   * @name jasmine.empty\n   * @function\n   */\n  j$.empty = function() {return new j$.Empty();};\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value being compared is not empty.\n   * @name jasmine.notEmpty\n   * @function\n   */\n  j$.notEmpty = function() {return new j$.NotEmpty();};\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value being compared contains at least the keys and values.\n   * @name jasmine.objectContaining\n   * @function\n   * @param {Object} sample - The subset of properties that _must_ be in the actual.\n   */\n  j$.objectContaining = function(sample) {\n    return new j$.ObjectContaining(sample);\n  };\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value is a `String` that matches the `RegExp` or `String`.\n   * @name jasmine.stringMatching\n   * @function\n   * @param {RegExp|String} expected\n   */\n  j$.stringMatching = function(expected) {\n    return new j$.StringMatching(expected);\n  };\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value is an `Array` that contains at least the elements in the sample.\n   * @name jasmine.arrayContaining\n   * @function\n   * @param {Array} sample\n   */\n  j$.arrayContaining = function(sample) {\n    return new j$.ArrayContaining(sample);\n  };\n\n  /**\n   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),\n   * that will succeed if the actual value is an `Array` that contains all of the elements in the sample in any order.\n   * @name jasmine.arrayWithExactContents\n   * @function\n   * @param {Array} sample\n   */\n  j$.arrayWithExactContents = function(sample) {\n    return new j$.ArrayWithExactContents(sample);\n  };\n\n  j$.isSpy = function(putativeSpy) {\n    if (!putativeSpy) {\n      return false;\n    }\n    return putativeSpy.and instanceof j$.SpyStrategy &&\n      putativeSpy.calls instanceof j$.CallTracker;\n  };\n};\n\ngetJasmineRequireObj().util = function(j$) {\n\n  var util = {};\n\n  util.inherit = function(childClass, parentClass) {\n    var Subclass = function() {\n    };\n    Subclass.prototype = parentClass.prototype;\n    childClass.prototype = new Subclass();\n  };\n\n  util.htmlEscape = function(str) {\n    if (!str) {\n      return str;\n    }\n    return str.replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n  };\n\n  util.argsToArray = function(args) {\n    var arrayOfArgs = [];\n    for (var i = 0; i < args.length; i++) {\n      arrayOfArgs.push(args[i]);\n    }\n    return arrayOfArgs;\n  };\n\n  util.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  util.arrayContains = function(array, search) {\n    var i = array.length;\n    while (i--) {\n      if (array[i] === search) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  util.clone = function(obj) {\n    if (Object.prototype.toString.apply(obj) === '[object Array]') {\n      return obj.slice();\n    }\n\n    var cloned = {};\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        cloned[prop] = obj[prop];\n      }\n    }\n\n    return cloned;\n  };\n\n  util.cloneArgs = function(args) {\n    var clonedArgs = [];\n    var argsAsArray = j$.util.argsToArray(args);\n    for(var i = 0; i < argsAsArray.length; i++) {\n      var str = Object.prototype.toString.apply(argsAsArray[i]),\n        primitives = /^\\[object (Boolean|String|RegExp|Number)/;\n\n      // All falsey values are either primitives, `null`, or `undefined.\n      if (!argsAsArray[i] || str.match(primitives)) {\n        clonedArgs.push(argsAsArray[i]);\n      } else {\n        clonedArgs.push(j$.util.clone(argsAsArray[i]));\n      }\n    }\n    return clonedArgs;\n  };\n\n  util.getPropertyDescriptor = function(obj, methodName) {\n    var descriptor,\n      proto = obj;\n\n    do {\n      descriptor = Object.getOwnPropertyDescriptor(proto, methodName);\n      proto = Object.getPrototypeOf(proto);\n    } while (!descriptor && proto);\n\n    return descriptor;\n  };\n\n  util.objectDifference = function(obj, toRemove) {\n    var diff = {};\n\n    for (var key in obj) {\n      if (util.has(obj, key) && !util.has(toRemove, key)) {\n        diff[key] = obj[key];\n      }\n    }\n\n    return diff;\n  };\n\n  util.has = function(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  };\n\n  function anyMatch(pattern, lines) {\n    var i;\n\n    for (i = 0; i < lines.length; i++) {\n      if (lines[i].match(pattern)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function errorWithStack() {\n    // Don't throw and catch if we don't have to, because it makes it harder\n    // for users to debug their code with exception breakpoints.\n    var error = new Error();\n\n    if (error.stack) {\n      return error;\n    }\n\n    // But some browsers (e.g. Phantom) only provide a stack trace if we throw.\n    try {\n      throw new Error();\n    } catch (e) {\n      return e;\n    }\n  }\n\n  function callerFile() {\n    var trace = new j$.StackTrace(errorWithStack().stack);\n    return trace.frames[2].file;\n  }\n\n  util.jasmineFile = (function() {\n    var result;\n\n    return function() {\n      var trace;\n\n      if (!result) {\n        result = callerFile();\n      }\n\n      return result;\n    };\n  }());\n\n  return util;\n};\n\ngetJasmineRequireObj().Spec = function(j$) {\n  function Spec(attrs) {\n    this.expectationFactory = attrs.expectationFactory;\n    this.resultCallback = attrs.resultCallback || function() {};\n    this.id = attrs.id;\n    this.description = attrs.description || '';\n    this.queueableFn = attrs.queueableFn;\n    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\n    this.userContext = attrs.userContext || function() { return {}; };\n    this.onStart = attrs.onStart || function() {};\n    this.getSpecName = attrs.getSpecName || function() { return ''; };\n    this.expectationResultFactory = attrs.expectationResultFactory || function() { };\n    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\n    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    if (!this.queueableFn.fn) {\n      this.pend();\n    }\n\n    /**\n     * @typedef SpecResult\n     * @property {Int} id - The unique id of this spec.\n     * @property {String} description - The description passed to the {@link it} that created this spec.\n     * @property {String} fullName - The full description including all ancestors of this spec.\n     * @property {Expectation[]} failedExpectations - The list of expectations that failed during execution of this spec.\n     * @property {Expectation[]} passedExpectations - The list of expectations that passed during execution of this spec.\n     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred during execution this spec.\n     * @property {String} pendingReason - If the spec is {@link pending}, this will be the reason.\n     * @property {String} status - Once the spec has completed, this string represents the pass/fail status of this spec.\n     */\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      passedExpectations: [],\n      deprecationWarnings: [],\n      pendingReason: ''\n    };\n  }\n\n  Spec.prototype.addExpectationResult = function(passed, data, isError) {\n    var expectationResult = this.expectationResultFactory(data);\n    if (passed) {\n      this.result.passedExpectations.push(expectationResult);\n    } else {\n      this.result.failedExpectations.push(expectationResult);\n\n      if (this.throwOnExpectationFailure && !isError) {\n        throw new j$.errors.ExpectationFailed();\n      }\n    }\n  };\n\n  Spec.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Spec.prototype.execute = function(onComplete, excluded) {\n    var self = this;\n\n    var onStart = {\n      fn: function(done) {\n        self.onStart(self, done);\n      }\n    };\n\n    var complete = {\n      fn: function(done) {\n        self.queueableFn.fn = null;\n        self.result.status = self.status(excluded);\n        self.resultCallback(self.result, done);\n      }\n    };\n\n    var fns = this.beforeAndAfterFns();\n    var regularFns = fns.befores.concat(this.queueableFn);\n\n    var runnerConfig = {\n      isLeaf: true,\n      queueableFns: regularFns,\n      cleanupFns: fns.afters,\n      onException: function () {\n        self.onException.apply(self, arguments);\n      },\n      onComplete: function() {\n        onComplete(self.result.status === 'failed' && new j$.StopExecutionError('spec failed'));\n      },\n      userContext: this.userContext()\n    };\n\n    if (this.markedPending || excluded === true) {\n      runnerConfig.queueableFns = [];\n      runnerConfig.cleanupFns = [];\n    }\n\n    runnerConfig.queueableFns.unshift(onStart);\n    runnerConfig.cleanupFns.push(complete);\n\n    this.queueRunnerFactory(runnerConfig);\n  };\n\n  Spec.prototype.onException = function onException(e) {\n    if (Spec.isPendingSpecException(e)) {\n      this.pend(extractCustomPendingMessage(e));\n      return;\n    }\n\n    if (e instanceof j$.errors.ExpectationFailed) {\n      return;\n    }\n\n    this.addExpectationResult(false, {\n      matcherName: '',\n      passed: false,\n      expected: '',\n      actual: '',\n      error: e\n    }, true);\n  };\n\n  Spec.prototype.pend = function(message) {\n    this.markedPending = true;\n    if (message) {\n      this.result.pendingReason = message;\n    }\n  };\n\n  Spec.prototype.getResult = function() {\n    this.result.status = this.status();\n    return this.result;\n  };\n\n  Spec.prototype.status = function(excluded) {\n    if (excluded === true) {\n      return 'excluded';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'passed';\n    }\n  };\n\n  Spec.prototype.getFullName = function() {\n    return this.getSpecName(this);\n  };\n\n  Spec.prototype.addDeprecationWarning = function(deprecation) {\n    if (typeof deprecation === 'string') {\n      deprecation = { message: deprecation };\n    }\n    this.result.deprecationWarnings.push(this.expectationResultFactory(deprecation));\n  };\n\n  var extractCustomPendingMessage = function(e) {\n    var fullMessage = e.toString(),\n        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\n        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\n\n    return fullMessage.substr(boilerplateEnd);\n  };\n\n  Spec.pendingSpecExceptionMessage = '=> marked Pending';\n\n  Spec.isPendingSpecException = function(e) {\n    return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\n  };\n\n  return Spec;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Spec = jasmineRequire.Spec;\n}\n\n/*jshint bitwise: false*/\n\ngetJasmineRequireObj().Order = function() {\n  function Order(options) {\n    this.random = 'random' in options ? options.random : true;\n    var seed = this.seed = options.seed || generateSeed();\n    this.sort = this.random ? randomOrder : naturalOrder;\n\n    function naturalOrder(items) {\n      return items;\n    }\n\n    function randomOrder(items) {\n      var copy = items.slice();\n      copy.sort(function(a, b) {\n        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);\n      });\n      return copy;\n    }\n\n    function generateSeed() {\n      return String(Math.random()).slice(-5);\n    }\n\n    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function\n    // used to get a different output when the key changes slighly.\n    // We use your return to sort the children randomly in a consistent way when\n    // used in conjunction with a seed\n\n    function jenkinsHash(key) {\n      var hash, i;\n      for(hash = i = 0; i < key.length; ++i) {\n        hash += key.charCodeAt(i);\n        hash += (hash << 10);\n        hash ^= (hash >> 6);\n      }\n      hash += (hash << 3);\n      hash ^= (hash >> 11);\n      hash += (hash << 15);\n      return hash;\n    }\n\n  }\n\n  return Order;\n};\n\ngetJasmineRequireObj().Env = function(j$) {\n  /**\n   * _Note:_ Do not construct this directly, Jasmine will make one during booting.\n   * @name Env\n   * @classdesc The Jasmine environment\n   * @constructor\n   */\n  function Env(options) {\n    options = options || {};\n\n    var self = this;\n    var global = options.global || j$.getGlobal();\n\n    var totalSpecsDefined = 0;\n\n    var realSetTimeout = j$.getGlobal().setTimeout;\n    var realClearTimeout = j$.getGlobal().clearTimeout;\n    var clearStack = j$.getClearStack(j$.getGlobal());\n    this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));\n\n    var runnableResources = {};\n\n    var currentSpec = null;\n    var currentlyExecutingSuites = [];\n    var currentDeclarationSuite = null;\n    var throwOnExpectationFailure = false;\n    var stopOnSpecFailure = false;\n    var random = true;\n    var seed = null;\n    var handlingLoadErrors = true;\n    var hasFailures = false;\n\n    var currentSuite = function() {\n      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\n    };\n\n    var currentRunnable = function() {\n      return currentSpec || currentSuite();\n    };\n\n    var globalErrors = null;\n    \n    var installGlobalErrors = function() {\n      if (globalErrors) {\n        return;\n      }\n\n      globalErrors = new j$.GlobalErrors();\n      globalErrors.install();\n    };\n\n    if (!options.suppressLoadErrors) {\n      installGlobalErrors();\n      globalErrors.pushListener(function(message, filename, lineno) {\n        topSuite.result.failedExpectations.push({\n          passed: false,\n          globalErrorType: 'load',\n          message: message,\n          filename: filename,\n          lineno: lineno\n        });\n      });\n    }\n\n    this.specFilter = function() {\n      return true;\n    };\n\n    this.addSpyStrategy = function(name, fn) {\n      if(!currentRunnable()) {\n        throw new Error('Custom spy strategies must be added in a before function or a spec');\n      }\n      runnableResources[currentRunnable().id].customSpyStrategies[name] = fn;\n    };\n\n    this.addCustomEqualityTester = function(tester) {\n      if(!currentRunnable()) {\n        throw new Error('Custom Equalities must be added in a before function or a spec');\n      }\n      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\n    };\n\n    this.addMatchers = function(matchersToAdd) {\n      if(!currentRunnable()) {\n        throw new Error('Matchers must be added in a before function or a spec');\n      }\n      var customMatchers = runnableResources[currentRunnable().id].customMatchers;\n      for (var matcherName in matchersToAdd) {\n        customMatchers[matcherName] = matchersToAdd[matcherName];\n      }\n    };\n\n    j$.Expectation.addCoreMatchers(j$.matchers);\n\n    var nextSpecId = 0;\n    var getNextSpecId = function() {\n      return 'spec' + nextSpecId++;\n    };\n\n    var nextSuiteId = 0;\n    var getNextSuiteId = function() {\n      return 'suite' + nextSuiteId++;\n    };\n\n    var expectationFactory = function(actual, spec) {\n      return j$.Expectation.Factory({\n        util: j$.matchersUtil,\n        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\n        customMatchers: runnableResources[spec.id].customMatchers,\n        actual: actual,\n        addExpectationResult: addExpectationResult\n      });\n\n      function addExpectationResult(passed, result) {\n        return spec.addExpectationResult(passed, result);\n      }\n    };\n\n    var defaultResourcesForRunnable = function(id, parentRunnableId) {\n      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}, customSpyStrategies: {}};\n\n      if(runnableResources[parentRunnableId]){\n        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\n        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\n      }\n\n      runnableResources[id] = resources;\n    };\n\n    var clearResourcesForRunnable = function(id) {\n        spyRegistry.clearSpies();\n        delete runnableResources[id];\n    };\n\n    var beforeAndAfterFns = function(suite) {\n      return function() {\n        var befores = [],\n          afters = [];\n\n        while(suite) {\n          befores = befores.concat(suite.beforeFns);\n          afters = afters.concat(suite.afterFns);\n\n          suite = suite.parentSuite;\n        }\n\n        return {\n          befores: befores.reverse(),\n          afters: afters\n        };\n      };\n    };\n\n    var getSpecName = function(spec, suite) {\n      var fullName = [spec.description],\n          suiteFullName = suite.getFullName();\n\n      if (suiteFullName !== '') {\n        fullName.unshift(suiteFullName);\n      }\n      return fullName.join(' ');\n    };\n\n    // TODO: we may just be able to pass in the fn instead of wrapping here\n    var buildExpectationResult = j$.buildExpectationResult,\n        exceptionFormatter = new j$.ExceptionFormatter(),\n        expectationResultFactory = function(attrs) {\n          attrs.messageFormatter = exceptionFormatter.message;\n          attrs.stackFormatter = exceptionFormatter.stack;\n\n          return buildExpectationResult(attrs);\n        };\n\n    var maximumSpecCallbackDepth = 20;\n    var currentSpecCallbackDepth = 0;\n\n    this.throwOnExpectationFailure = function(value) {\n      throwOnExpectationFailure = !!value;\n    };\n\n    this.throwingExpectationFailures = function() {\n      return throwOnExpectationFailure;\n    };\n\n    this.stopOnSpecFailure = function(value) {\n      stopOnSpecFailure = !!value;\n    };\n\n    this.stoppingOnSpecFailure = function() {\n      return stopOnSpecFailure;\n    };\n\n    this.randomizeTests = function(value) {\n      random = !!value;\n    };\n\n    this.randomTests = function() {\n      return random;\n    };\n\n    this.seed = function(value) {\n      if (value) {\n        seed = value;\n      }\n      return seed;\n    };\n\n    this.deprecated = function(deprecation) {\n      var runnable = currentRunnable() || topSuite;\n      runnable.addDeprecationWarning(deprecation);\n      if(typeof console !== 'undefined' && typeof console.error === 'function') {\n        console.error('DEPRECATION:', deprecation);\n      }\n    };\n\n    var queueRunnerFactory = function(options, args) {\n      var failFast = false;\n      if (options.isLeaf) {\n        failFast = throwOnExpectationFailure;\n      } else if (!options.isReporter) {\n        failFast = stopOnSpecFailure;\n      }\n      options.clearStack = options.clearStack || clearStack;\n      options.timeout = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\n      options.fail = self.fail;\n      options.globalErrors = globalErrors;\n      options.completeOnFirstError = failFast;\n      options.onException = options.onException || function(e) {\n        (currentRunnable() || topSuite).onException(e);\n      };\n      options.deprecated = self.deprecated;\n\n      new j$.QueueRunner(options).execute(args);\n    };\n\n    var topSuite = new j$.Suite({\n      env: this,\n      id: getNextSuiteId(),\n      description: 'Jasmine__TopLevel__Suite',\n      expectationFactory: expectationFactory,\n      expectationResultFactory: expectationResultFactory\n    });\n    defaultResourcesForRunnable(topSuite.id);\n    currentDeclarationSuite = topSuite;\n\n    this.topSuite = function() {\n      return topSuite;\n    };\n\n    /**\n     * This represents the available reporter callback for an object passed to {@link Env#addReporter}.\n     * @interface Reporter\n     */\n    var reporter = new j$.ReportDispatcher([\n      /**\n       * `jasmineStarted` is called after all of the specs have been loaded, but just before execution starts.\n       * @function\n       * @name Reporter#jasmineStarted\n       * @param {JasmineStartedInfo} suiteInfo Information about the full Jasmine suite that is being run\n       * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.\n       * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.\n       */\n      'jasmineStarted',\n      /**\n       * When the entire suite has finished execution `jasmineDone` is called\n       * @function\n       * @name Reporter#jasmineDone\n       * @param {JasmineDoneInfo} suiteInfo Information about the full Jasmine suite that just finished running.\n       * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.\n       * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.\n       */\n      'jasmineDone',\n      /**\n       * `suiteStarted` is invoked when a `describe` starts to run\n       * @function\n       * @name Reporter#suiteStarted\n       * @param {SuiteResult} result Information about the individual {@link describe} being run\n       * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.\n       * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.\n       */\n      'suiteStarted',\n      /**\n       * `suiteDone` is invoked when all of the child specs and suites for a given suite have been run\n       *\n       * While jasmine doesn't require any specific functions, not defining a `suiteDone` will make it impossible for a reporter to know when a suite has failures in an `afterAll`.\n       * @function\n       * @name Reporter#suiteDone\n       * @param {SuiteResult} result\n       * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.\n       * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.\n       */\n      'suiteDone',\n      /**\n       * `specStarted` is invoked when an `it` starts to run (including associated `beforeEach` functions)\n       * @function\n       * @name Reporter#specStarted\n       * @param {SpecResult} result Information about the individual {@link it} being run\n       * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.\n       * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.\n       */\n      'specStarted',\n      /**\n       * `specDone` is invoked when an `it` and its associated `beforeEach` and `afterEach` functions have been run.\n       *\n       * While jasmine doesn't require any specific functions, not defining a `specDone` will make it impossible for a reporter to know when a spec has failed.\n       * @function\n       * @name Reporter#specDone\n       * @param {SpecResult} result\n       * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.\n       * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.\n       */\n      'specDone'\n    ], queueRunnerFactory);\n\n    this.execute = function(runnablesToRun) {\n      var self = this;\n      installGlobalErrors();\n\n      if(!runnablesToRun) {\n        if (focusedRunnables.length) {\n          runnablesToRun = focusedRunnables;\n        } else {\n          runnablesToRun = [topSuite.id];\n        }\n      }\n\n      var order = new j$.Order({\n        random: random,\n        seed: seed\n      });\n\n      var processor = new j$.TreeProcessor({\n        tree: topSuite,\n        runnableIds: runnablesToRun,\n        queueRunnerFactory: queueRunnerFactory,\n        nodeStart: function(suite, next) {\n          currentlyExecutingSuites.push(suite);\n          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\n          reporter.suiteStarted(suite.result, next);\n        },\n        nodeComplete: function(suite, result, next) {\n          if (suite !== currentSuite()) {\n            throw new Error('Tried to complete the wrong suite');\n          }\n\n          clearResourcesForRunnable(suite.id);\n          currentlyExecutingSuites.pop();\n\n          if (result.status === 'failed') {\n            hasFailures = true;\n          }\n\n          reporter.suiteDone(result, next);\n        },\n        orderChildren: function(node) {\n          return order.sort(node.children);\n        },\n        excludeNode: function(spec) {\n          return !self.specFilter(spec);\n        }\n      });\n\n      if(!processor.processTree().valid) {\n        throw new Error('Invalid order: would cause a beforeAll or afterAll to be run multiple times');\n      }\n\n      /**\n       * Information passed to the {@link Reporter#jasmineStarted} event.\n       * @typedef JasmineStartedInfo\n       * @property {Int} totalSpecsDefined - The total number of specs defined in this suite.\n       * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.\n       */\n      reporter.jasmineStarted({\n        totalSpecsDefined: totalSpecsDefined,\n        order: order\n      }, function() {\n        currentlyExecutingSuites.push(topSuite);\n\n        processor.execute(function () {\n          clearResourcesForRunnable(topSuite.id);\n          currentlyExecutingSuites.pop();\n          var overallStatus, incompleteReason;\n\n          if (hasFailures || topSuite.result.failedExpectations.length > 0) {\n            overallStatus = 'failed';\n          } else if (focusedRunnables.length > 0) {\n            overallStatus = 'incomplete';\n            incompleteReason = 'fit() or fdescribe() was found';\n          } else if (totalSpecsDefined === 0) {\n            overallStatus = 'incomplete';\n            incompleteReason = 'No specs found';\n          } else {\n            overallStatus = 'passed';\n          }\n\n          /**\n           * Information passed to the {@link Reporter#jasmineDone} event.\n           * @typedef JasmineDoneInfo\n           * @property {OverallStatus} - The overall result of the sute: 'passed', 'failed', or 'incomplete'.\n           * @property {IncompleteReason} - Explanation of why the suite was incimplete.\n           * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.\n           * @property {Expectation[]} failedExpectations - List of expectations that failed in an {@link afterAll} at the global level.\n           * @property {Expectation[]} deprecationWarnings - List of deprecation warnings that occurred at the global level.\n           */\n          reporter.jasmineDone({\n            overallStatus: overallStatus,\n            incompleteReason: incompleteReason,\n            order: order,\n            failedExpectations: topSuite.result.failedExpectations,\n            deprecationWarnings: topSuite.result.deprecationWarnings\n          }, function() {});\n        });\n      });\n    };\n\n    /**\n     * Add a custom reporter to the Jasmine environment.\n     * @name Env#addReporter\n     * @function\n     * @param {Reporter} reporterToAdd The reporter to be added.\n     * @see custom_reporter\n     */\n    this.addReporter = function(reporterToAdd) {\n      reporter.addReporter(reporterToAdd);\n    };\n\n    this.provideFallbackReporter = function(reporterToAdd) {\n      reporter.provideFallbackReporter(reporterToAdd);\n    };\n\n    this.clearReporters = function() {\n      reporter.clearReporters();\n    };\n\n    var spyFactory = new j$.SpyFactory(function() {\n      var runnable = currentRunnable();\n\n      if (runnable) {\n        return runnableResources[runnable.id].customSpyStrategies;\n      }\n\n      return {};\n    });\n\n    var spyRegistry = new j$.SpyRegistry({\n      currentSpies: function() {\n        if(!currentRunnable()) {\n          throw new Error('Spies must be created in a before function or a spec');\n        }\n        return runnableResources[currentRunnable().id].spies;\n      },\n      createSpy: function(name, originalFn) {\n        return self.createSpy(name, originalFn);\n      }\n    });\n\n    this.allowRespy = function(allow){\n      spyRegistry.allowRespy(allow);\n    };\n\n    this.spyOn = function() {\n      return spyRegistry.spyOn.apply(spyRegistry, arguments);\n    };\n\n    this.spyOnProperty = function() {\n      return spyRegistry.spyOnProperty.apply(spyRegistry, arguments);\n    };\n\n    this.createSpy = function(name, originalFn) {\n      return spyFactory.createSpy(name, originalFn);\n    };\n\n    this.createSpyObj = function(baseName, methodNames) {\n      return spyFactory.createSpyObj(baseName, methodNames);\n    };\n\n    var ensureIsFunction = function(fn, caller) {\n      if (!j$.isFunction_(fn)) {\n        throw new Error(caller + ' expects a function argument; received ' + j$.getType_(fn));\n      }\n    };\n\n    var ensureIsFunctionOrAsync = function(fn, caller) {\n      if (!j$.isFunction_(fn) && !j$.isAsyncFunction_(fn)) {\n        throw new Error(caller + ' expects a function argument; received ' + j$.getType_(fn));\n      }\n    };\n\n    function ensureIsNotNested(method) {\n      var runnable = currentRunnable();\n      if (runnable !== null && runnable !== undefined) {\n        throw new Error('\\'' + method + '\\' should only be used in \\'describe\\' function');\n      }\n    }\n\n    var suiteFactory = function(description) {\n      var suite = new j$.Suite({\n        env: self,\n        id: getNextSuiteId(),\n        description: description,\n        parentSuite: currentDeclarationSuite,\n        expectationFactory: expectationFactory,\n        expectationResultFactory: expectationResultFactory,\n        throwOnExpectationFailure: throwOnExpectationFailure\n      });\n\n      return suite;\n    };\n\n    this.describe = function(description, specDefinitions) {\n      ensureIsNotNested('describe');\n      ensureIsFunction(specDefinitions, 'describe');\n      var suite = suiteFactory(description);\n      if (specDefinitions.length > 0) {\n        throw new Error('describe does not expect any arguments');\n      }\n      if (currentDeclarationSuite.markedPending) {\n        suite.pend();\n      }\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n\n    this.xdescribe = function(description, specDefinitions) {\n      ensureIsNotNested('xdescribe');\n      ensureIsFunction(specDefinitions, 'xdescribe');\n      var suite = suiteFactory(description);\n      suite.pend();\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n\n    var focusedRunnables = [];\n\n    this.fdescribe = function(description, specDefinitions) {\n      ensureIsNotNested('fdescribe');\n      ensureIsFunction(specDefinitions, 'fdescribe');\n      var suite = suiteFactory(description);\n      suite.isFocused = true;\n\n      focusedRunnables.push(suite.id);\n      unfocusAncestor();\n      addSpecsToSuite(suite, specDefinitions);\n\n      return suite;\n    };\n\n    function addSpecsToSuite(suite, specDefinitions) {\n      var parentSuite = currentDeclarationSuite;\n      parentSuite.addChild(suite);\n      currentDeclarationSuite = suite;\n\n      var declarationError = null;\n      try {\n        specDefinitions.call(suite);\n      } catch (e) {\n        declarationError = e;\n      }\n\n      if (declarationError) {\n        suite.onException(declarationError);\n      }\n\n      currentDeclarationSuite = parentSuite;\n    }\n\n    function findFocusedAncestor(suite) {\n      while (suite) {\n        if (suite.isFocused) {\n          return suite.id;\n        }\n        suite = suite.parentSuite;\n      }\n\n      return null;\n    }\n\n    function unfocusAncestor() {\n      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n      if (focusedAncestor) {\n        for (var i = 0; i < focusedRunnables.length; i++) {\n          if (focusedRunnables[i] === focusedAncestor) {\n            focusedRunnables.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    var specFactory = function(description, fn, suite, timeout) {\n      totalSpecsDefined++;\n      var spec = new j$.Spec({\n        id: getNextSpecId(),\n        beforeAndAfterFns: beforeAndAfterFns(suite),\n        expectationFactory: expectationFactory,\n        resultCallback: specResultCallback,\n        getSpecName: function(spec) {\n          return getSpecName(spec, suite);\n        },\n        onStart: specStarted,\n        description: description,\n        expectationResultFactory: expectationResultFactory,\n        queueRunnerFactory: queueRunnerFactory,\n        userContext: function() { return suite.clonedSharedUserContext(); },\n        queueableFn: {\n          fn: fn,\n          timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n        },\n        throwOnExpectationFailure: throwOnExpectationFailure\n      });\n\n      return spec;\n\n      function specResultCallback(result, next) {\n        clearResourcesForRunnable(spec.id);\n        currentSpec = null;\n\n        if (result.status === 'failed') {\n          hasFailures = true;\n        }\n\n        reporter.specDone(result, next);\n      }\n\n      function specStarted(spec, next) {\n        currentSpec = spec;\n        defaultResourcesForRunnable(spec.id, suite.id);\n        reporter.specStarted(spec.result, next);\n      }\n    };\n\n    this.it = function(description, fn, timeout) {\n      ensureIsNotNested('it');\n      // it() sometimes doesn't have a fn argument, so only check the type if\n      // it's given.\n      if (arguments.length > 1 && typeof fn !== 'undefined') {\n        ensureIsFunctionOrAsync(fn, 'it');\n      }\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      if (currentDeclarationSuite.markedPending) {\n        spec.pend();\n      }\n      currentDeclarationSuite.addChild(spec);\n      return spec;\n    };\n\n    this.xit = function(description, fn, timeout) {\n      ensureIsNotNested('xit');\n      // xit(), like it(), doesn't always have a fn argument, so only check the\n      // type when needed.\n      if (arguments.length > 1 && typeof fn !== 'undefined') {\n        ensureIsFunctionOrAsync(fn, 'xit');\n      }\n      var spec = this.it.apply(this, arguments);\n      spec.pend('Temporarily disabled with xit');\n      return spec;\n    };\n\n    this.fit = function(description, fn, timeout){\n      ensureIsNotNested('fit');\n      ensureIsFunctionOrAsync(fn, 'fit');\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      currentDeclarationSuite.addChild(spec);\n      focusedRunnables.push(spec.id);\n      unfocusAncestor();\n      return spec;\n    };\n\n    this.expect = function(actual) {\n      if (!currentRunnable()) {\n        throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\n      }\n\n      return currentRunnable().expect(actual);\n    };\n\n    this.beforeEach = function(beforeEachFunction, timeout) {\n      ensureIsNotNested('beforeEach');\n      ensureIsFunctionOrAsync(beforeEachFunction, 'beforeEach');\n      currentDeclarationSuite.beforeEach({\n        fn: beforeEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.beforeAll = function(beforeAllFunction, timeout) {\n      ensureIsNotNested('beforeAll');\n      ensureIsFunctionOrAsync(beforeAllFunction, 'beforeAll');\n      currentDeclarationSuite.beforeAll({\n        fn: beforeAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterEach = function(afterEachFunction, timeout) {\n      ensureIsNotNested('afterEach');\n      ensureIsFunctionOrAsync(afterEachFunction, 'afterEach');\n      afterEachFunction.isCleanup = true;\n      currentDeclarationSuite.afterEach({\n        fn: afterEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterAll = function(afterAllFunction, timeout) {\n      ensureIsNotNested('afterAll');\n      ensureIsFunctionOrAsync(afterAllFunction, 'afterAll');\n      currentDeclarationSuite.afterAll({\n        fn: afterAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.pending = function(message) {\n      var fullMessage = j$.Spec.pendingSpecExceptionMessage;\n      if(message) {\n        fullMessage += message;\n      }\n      throw fullMessage;\n    };\n\n    this.fail = function(error) {\n      if (!currentRunnable()) {\n        throw new Error('\\'fail\\' was used when there was no current spec, this could be because an asynchronous test timed out');\n      }\n\n      var message = 'Failed';\n      if (error) {\n        message += ': ';\n        if (error.message) {\n          message += error.message;\n        } else if (jasmine.isString_(error)) {\n          message += error;\n        } else {\n          // pretty print all kind of objects. This includes arrays.\n          message += jasmine.pp(error);\n        }\n      }\n\n      currentRunnable().addExpectationResult(false, {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        message: message,\n        error: error && error.message ? error : null\n      });\n\n      if (self.throwingExpectationFailures()) {\n        throw new Error(message);\n      }\n    };\n  }\n\n  return Env;\n};\n\ngetJasmineRequireObj().JsApiReporter = function() {\n\n  var noopTimer = {\n    start: function(){},\n    elapsed: function(){ return 0; }\n  };\n\n  /**\n   * @name jsApiReporter\n   * @classdesc {@link Reporter} added by default in `boot.js` to record results for retrieval in javascript code. An instance is made available as `jsApiReporter` on the global object.\n   * @class\n   * @hideconstructor\n   */\n  function JsApiReporter(options) {\n    var timer = options.timer || noopTimer,\n        status = 'loaded';\n\n    this.started = false;\n    this.finished = false;\n    this.runDetails = {};\n\n    this.jasmineStarted = function() {\n      this.started = true;\n      status = 'started';\n      timer.start();\n    };\n\n    var executionTime;\n\n    this.jasmineDone = function(runDetails) {\n      this.finished = true;\n      this.runDetails = runDetails;\n      executionTime = timer.elapsed();\n      status = 'done';\n    };\n\n    /**\n     * Get the current status for the Jasmine environment.\n     * @name jsApiReporter#status\n     * @function\n     * @return {String} - One of `loaded`, `started`, or `done`\n     */\n    this.status = function() {\n      return status;\n    };\n\n    var suites = [],\n      suites_hash = {};\n\n    this.suiteStarted = function(result) {\n      suites_hash[result.id] = result;\n    };\n\n    this.suiteDone = function(result) {\n      storeSuite(result);\n    };\n\n    /**\n     * Get the results for a set of suites.\n     *\n     * Retrievable in slices for easier serialization.\n     * @name jsApiReporter#suiteResults\n     * @function\n     * @param {Number} index - The position in the suites list to start from.\n     * @param {Number} length - Maximum number of suite results to return.\n     * @return {SuiteResult[]}\n     */\n    this.suiteResults = function(index, length) {\n      return suites.slice(index, index + length);\n    };\n\n    function storeSuite(result) {\n      suites.push(result);\n      suites_hash[result.id] = result;\n    }\n\n    /**\n     * Get all of the suites in a single object, with their `id` as the key.\n     * @name jsApiReporter#suites\n     * @function\n     * @return {Object} - Map of suite id to {@link SuiteResult}\n     */\n    this.suites = function() {\n      return suites_hash;\n    };\n\n    var specs = [];\n\n    this.specDone = function(result) {\n      specs.push(result);\n    };\n\n    /**\n     * Get the results for a set of specs.\n     *\n     * Retrievable in slices for easier serialization.\n     * @name jsApiReporter#specResults\n     * @function\n     * @param {Number} index - The position in the specs list to start from.\n     * @param {Number} length - Maximum number of specs results to return.\n     * @return {SpecResult[]}\n     */\n    this.specResults = function(index, length) {\n      return specs.slice(index, index + length);\n    };\n\n    /**\n     * Get all spec results.\n     * @name jsApiReporter#specs\n     * @function\n     * @return {SpecResult[]}\n     */\n    this.specs = function() {\n      return specs;\n    };\n\n    /**\n     * Get the number of milliseconds it took for the full Jasmine suite to run.\n     * @name jsApiReporter#executionTime\n     * @function\n     * @return {Number}\n     */\n    this.executionTime = function() {\n      return executionTime;\n    };\n\n  }\n\n  return JsApiReporter;\n};\n\ngetJasmineRequireObj().Any = function(j$) {\n\n  function Any(expectedObject) {\n    if (typeof expectedObject === 'undefined') {\n      throw new TypeError(\n        'jasmine.any() expects to be passed a constructor function. ' +\n        'Please pass one or use jasmine.anything() to match any object.'\n      );\n    }\n    this.expectedObject = expectedObject;\n  }\n\n  Any.prototype.asymmetricMatch = function(other) {\n    if (this.expectedObject == String) {\n      return typeof other == 'string' || other instanceof String;\n    }\n\n    if (this.expectedObject == Number) {\n      return typeof other == 'number' || other instanceof Number;\n    }\n\n    if (this.expectedObject == Function) {\n      return typeof other == 'function' || other instanceof Function;\n    }\n\n    if (this.expectedObject == Object) {\n      return other !== null && typeof other == 'object';\n    }\n\n    if (this.expectedObject == Boolean) {\n      return typeof other == 'boolean';\n    }\n\n    /* jshint -W122 */\n    if (typeof Symbol != 'undefined' && this.expectedObject == Symbol) {\n      return typeof other == 'symbol';\n    }\n    /* jshint +W122 */\n\n    return other instanceof this.expectedObject;\n  };\n\n  Any.prototype.jasmineToString = function() {\n    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';\n  };\n\n  return Any;\n};\n\ngetJasmineRequireObj().Anything = function(j$) {\n\n  function Anything() {}\n\n  Anything.prototype.asymmetricMatch = function(other) {\n    return !j$.util.isUndefined(other) && other !== null;\n  };\n\n  Anything.prototype.jasmineToString = function() {\n    return '<jasmine.anything>';\n  };\n\n  return Anything;\n};\n\ngetJasmineRequireObj().ArrayContaining = function(j$) {\n  function ArrayContaining(sample) {\n    this.sample = sample;\n  }\n\n  ArrayContaining.prototype.asymmetricMatch = function(other, customTesters) {\n    if (!j$.isArray_(this.sample)) {\n      throw new Error('You must provide an array to arrayContaining, not ' + j$.pp(this.sample) + '.');\n    }\n\n    for (var i = 0; i < this.sample.length; i++) {\n      var item = this.sample[i];\n      if (!j$.matchersUtil.contains(other, item, customTesters)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ArrayContaining.prototype.jasmineToString = function () {\n    return '<jasmine.arrayContaining(' + jasmine.pp(this.sample) +')>';\n  };\n\n  return ArrayContaining;\n};\n\ngetJasmineRequireObj().ArrayWithExactContents = function(j$) {\n\n  function ArrayWithExactContents(sample) {\n    this.sample = sample;\n  }\n\n  ArrayWithExactContents.prototype.asymmetricMatch = function(other, customTesters) {\n    if (!j$.isArray_(this.sample)) {\n      throw new Error('You must provide an array to arrayWithExactContents, not ' + j$.pp(this.sample) + '.');\n    }\n\n    if (this.sample.length !== other.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.sample.length; i++) {\n      var item = this.sample[i];\n      if (!j$.matchersUtil.contains(other, item, customTesters)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ArrayWithExactContents.prototype.jasmineToString = function() {\n    return '<jasmine.arrayWithExactContents ' + j$.pp(this.sample) + '>';\n  };\n\n  return ArrayWithExactContents;\n};\n\ngetJasmineRequireObj().Empty = function (j$) {\n\n  function Empty() {}\n\n  Empty.prototype.asymmetricMatch = function (other) {\n    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {\n      return other.length === 0;\n    }\n\n    if (j$.isMap(other) || j$.isSet(other)) {\n      return other.size === 0;\n    }\n\n    if (j$.isObject_(other)) {\n      return Object.keys(other).length === 0;\n    }\n    return false;\n  };\n\n  Empty.prototype.jasmineToString = function () {\n    return '<jasmine.empty>';\n  };\n\n  return Empty;\n};\n\ngetJasmineRequireObj().Falsy = function(j$) {\n\n  function Falsy() {}\n\n  Falsy.prototype.asymmetricMatch = function(other) {\n    return !other;\n  };\n\n  Falsy.prototype.jasmineToString = function() {\n    return '<jasmine.falsy>';\n  };\n\n  return Falsy;\n};\n\ngetJasmineRequireObj().NotEmpty = function (j$) {\n\n  function NotEmpty() {}\n\n  NotEmpty.prototype.asymmetricMatch = function (other) {\n    if (j$.isString_(other) || j$.isArray_(other) || j$.isTypedArray_(other)) {\n      return other.length !== 0;\n    }\n\n    if (j$.isMap(other) || j$.isSet(other)) {\n      return other.size !== 0;\n    }\n\n    if (j$.isObject_(other)) {\n      return Object.keys(other).length !== 0;\n    }\n\n    return false;\n  };\n\n  NotEmpty.prototype.jasmineToString = function () {\n    return '<jasmine.notEmpty>';\n  };\n\n  return NotEmpty;\n};\n\ngetJasmineRequireObj().ObjectContaining = function(j$) {\n\n  function ObjectContaining(sample) {\n    this.sample = sample;\n  }\n\n  function getPrototype(obj) {\n    if (Object.getPrototypeOf) {\n      return Object.getPrototypeOf(obj);\n    }\n\n    if (obj.constructor.prototype == obj) {\n      return null;\n    }\n\n    return obj.constructor.prototype;\n  }\n\n  function hasProperty(obj, property) {\n    if (!obj) {\n      return false;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\n      return true;\n    }\n\n    return hasProperty(getPrototype(obj), property);\n  }\n\n  ObjectContaining.prototype.asymmetricMatch = function(other, customTesters) {\n    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \\''+this.sample+'\\'.'); }\n\n    for (var property in this.sample) {\n      if (!hasProperty(other, property) ||\n          !j$.matchersUtil.equals(this.sample[property], other[property], customTesters)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ObjectContaining.prototype.jasmineToString = function() {\n    return '<jasmine.objectContaining(' + j$.pp(this.sample) + ')>';\n  };\n\n  return ObjectContaining;\n};\n\ngetJasmineRequireObj().StringMatching = function(j$) {\n\n  function StringMatching(expected) {\n    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n      throw new Error('Expected is not a String or a RegExp');\n    }\n\n    this.regexp = new RegExp(expected);\n  }\n\n  StringMatching.prototype.asymmetricMatch = function(other) {\n    return this.regexp.test(other);\n  };\n\n  StringMatching.prototype.jasmineToString = function() {\n    return '<jasmine.stringMatching(' + this.regexp + ')>';\n  };\n\n  return StringMatching;\n};\n\ngetJasmineRequireObj().Truthy = function(j$) {\n\n  function Truthy() {}\n\n  Truthy.prototype.asymmetricMatch = function(other) {\n    return !!other;\n  };\n\n  Truthy.prototype.jasmineToString = function() {\n    return '<jasmine.truthy>';\n  };\n\n  return Truthy;\n};\n\ngetJasmineRequireObj().CallTracker = function(j$) {\n\n  /**\n   * @namespace Spy#calls\n   */\n  function CallTracker() {\n    var calls = [];\n    var opts = {};\n\n    this.track = function(context) {\n      if(opts.cloneArgs) {\n        context.args = j$.util.cloneArgs(context.args);\n      }\n      calls.push(context);\n    };\n\n    /**\n     * Check whether this spy has been invoked.\n     * @name Spy#calls#any\n     * @function\n     * @return {Boolean}\n     */\n    this.any = function() {\n      return !!calls.length;\n    };\n\n    /**\n     * Get the number of invocations of this spy.\n     * @name Spy#calls#count\n     * @function\n     * @return {Integer}\n     */\n    this.count = function() {\n      return calls.length;\n    };\n\n    /**\n     * Get the arguments that were passed to a specific invocation of this spy.\n     * @name Spy#calls#argsFor\n     * @function\n     * @param {Integer} index The 0-based invocation index.\n     * @return {Array}\n     */\n    this.argsFor = function(index) {\n      var call = calls[index];\n      return call ? call.args : [];\n    };\n\n    /**\n     * Get the raw calls array for this spy.\n     * @name Spy#calls#all\n     * @function\n     * @return {Spy.callData[]}\n     */\n    this.all = function() {\n      return calls;\n    };\n\n    /**\n     * Get all of the arguments for each invocation of this spy in the order they were received.\n     * @name Spy#calls#allArgs\n     * @function\n     * @return {Array}\n     */\n    this.allArgs = function() {\n      var callArgs = [];\n      for(var i = 0; i < calls.length; i++){\n        callArgs.push(calls[i].args);\n      }\n\n      return callArgs;\n    };\n\n    /**\n     * Get the first invocation of this spy.\n     * @name Spy#calls#first\n     * @function\n     * @return {ObjecSpy.callData}\n     */\n    this.first = function() {\n      return calls[0];\n    };\n\n    /**\n     * Get the most recent invocation of this spy.\n     * @name Spy#calls#mostRecent\n     * @function\n     * @return {ObjecSpy.callData}\n     */\n    this.mostRecent = function() {\n      return calls[calls.length - 1];\n    };\n\n    /**\n     * Reset this spy as if it has never been called.\n     * @name Spy#calls#reset\n     * @function\n     */\n    this.reset = function() {\n      calls = [];\n    };\n\n    /**\n     * Set this spy to do a shallow clone of arguments passed to each invocation.\n     * @name Spy#calls#saveArgumentsByValue\n     * @function\n     */\n    this.saveArgumentsByValue = function() {\n      opts.cloneArgs = true;\n    };\n\n  }\n\n  return CallTracker;\n};\n\ngetJasmineRequireObj().clearStack = function(j$) {\n  var maxInlineCallCount = 10;\n\n  function messageChannelImpl(global, setTimeout) {\n    var channel = new global.MessageChannel(),\n        head = {},\n        tail = head;\n\n    var taskRunning = false;\n    channel.port1.onmessage = function() {\n      head = head.next;\n      var task = head.task;\n      delete head.task;\n\n      if (taskRunning) {\n        global.setTimeout(task, 0);\n      } else {\n        try {\n          taskRunning = true;\n          task();\n        } finally {\n          taskRunning = false;\n        }\n      }\n    };\n\n    var currentCallCount = 0;\n    return function clearStack(fn) {\n      currentCallCount++;\n\n      if (currentCallCount < maxInlineCallCount) {\n        tail = tail.next = { task: fn };\n        channel.port2.postMessage(0);\n      } else {\n        currentCallCount = 0;\n        setTimeout(fn);\n      }\n    };\n  }\n\n  function getClearStack(global) {\n    var currentCallCount = 0;\n    var realSetTimeout = global.setTimeout;\n    var setTimeoutImpl = function clearStack(fn) {\n        Function.prototype.apply.apply(realSetTimeout, [global, [fn, 0]]);\n    };\n\n    if (j$.isFunction_(global.setImmediate)) {\n      var realSetImmediate = global.setImmediate;\n      return function(fn) {\n        currentCallCount++;\n\n        if (currentCallCount < maxInlineCallCount) {\n          realSetImmediate(fn);\n        } else {\n          currentCallCount = 0;\n\n          setTimeoutImpl(fn);\n        }\n      };\n    } else if (!j$.util.isUndefined(global.MessageChannel)) {\n      return messageChannelImpl(global, setTimeoutImpl);\n    } else {\n      return setTimeoutImpl;\n    }\n  }\n\n  return getClearStack;\n};\n\ngetJasmineRequireObj().Clock = function() {\n\n  var NODE_JS = typeof process !== 'undefined' && process.versions && typeof process.versions.node === 'string';\n\n  /**\n   * _Note:_ Do not construct this directly, Jasmine will make one during booting. You can get the current clock with {@link jasmine.clock}.\n   * @class Clock\n   * @classdesc Jasmine's mock clock is used when testing time dependent code.\n   */\n  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {\n    var self = this,\n      realTimingFunctions = {\n        setTimeout: global.setTimeout,\n        clearTimeout: global.clearTimeout,\n        setInterval: global.setInterval,\n        clearInterval: global.clearInterval\n      },\n      fakeTimingFunctions = {\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout,\n        setInterval: setInterval,\n        clearInterval: clearInterval\n      },\n      installed = false,\n      delayedFunctionScheduler,\n      timer;\n\n    self.FakeTimeout = FakeTimeout;\n\n    /**\n     * Install the mock clock over the built-in methods.\n     * @name Clock#install\n     * @function\n     * @return {Clock}\n     */\n    self.install = function() {\n      if(!originalTimingFunctionsIntact()) {\n        throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');\n      }\n      replace(global, fakeTimingFunctions);\n      timer = fakeTimingFunctions;\n      delayedFunctionScheduler = delayedFunctionSchedulerFactory();\n      installed = true;\n\n      return self;\n    };\n\n    /**\n     * Uninstall the mock clock, returning the built-in methods to their places.\n     * @name Clock#uninstall\n     * @function\n     */\n    self.uninstall = function() {\n      delayedFunctionScheduler = null;\n      mockDate.uninstall();\n      replace(global, realTimingFunctions);\n\n      timer = realTimingFunctions;\n      installed = false;\n    };\n\n    /**\n     * Execute a function with a mocked Clock\n     *\n     * The clock will be {@link Clock#install|install}ed before the function is called and {@link Clock#uninstall|uninstall}ed in a `finally` after the function completes.\n     * @name Clock#withMock\n     * @function\n     * @param {closure} Function The function to be called.\n     */\n    self.withMock = function(closure) {\n      this.install();\n      try {\n        closure();\n      } finally {\n        this.uninstall();\n      }\n    };\n\n    /**\n     * Instruct the installed Clock to also mock the date returned by `new Date()`\n     * @name Clock#mockDate\n     * @function\n     * @param {Date} [initialDate=now] The `Date` to provide.\n     */\n    self.mockDate = function(initialDate) {\n      mockDate.install(initialDate);\n    };\n\n    self.setTimeout = function(fn, delay, params) {\n      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\n    };\n\n    self.setInterval = function(fn, delay, params) {\n      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\n    };\n\n    self.clearTimeout = function(id) {\n      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\n    };\n\n    self.clearInterval = function(id) {\n      return Function.prototype.call.apply(timer.clearInterval, [global, id]);\n    };\n\n    /**\n     * Tick the Clock forward, running any enqueued timeouts along the way\n     * @name Clock#tick\n     * @function\n     * @param {int} millis The number of milliseconds to tick.\n     */\n    self.tick = function(millis) {\n      if (installed) {\n        delayedFunctionScheduler.tick(millis, function(millis) { mockDate.tick(millis); });\n      } else {\n        throw new Error('Mock clock is not installed, use jasmine.clock().install()');\n      }\n    };\n\n    return self;\n\n    function originalTimingFunctionsIntact() {\n      return global.setTimeout === realTimingFunctions.setTimeout &&\n        global.clearTimeout === realTimingFunctions.clearTimeout &&\n        global.setInterval === realTimingFunctions.setInterval &&\n        global.clearInterval === realTimingFunctions.clearInterval;\n    }\n\n    function replace(dest, source) {\n      for (var prop in source) {\n        dest[prop] = source[prop];\n      }\n    }\n\n    function setTimeout(fn, delay) {\n      if (!NODE_JS) {\n        return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\n      }\n\n      var timeout = new FakeTimeout();\n\n      delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2), false, timeout);\n\n      return timeout;\n    }\n\n    function clearTimeout(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function setInterval(fn, interval) {\n      if (!NODE_JS) {\n        return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\n      }\n\n      var timeout = new FakeTimeout();\n\n      delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true, timeout);\n\n      return timeout;\n    }\n\n    function clearInterval(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function argSlice(argsObj, n) {\n      return Array.prototype.slice.call(argsObj, n);\n    }\n  }\n\n  /**\n   * Mocks Node.js Timeout class\n   */\n  function FakeTimeout() {}\n\n  FakeTimeout.prototype.ref = function () {\n    return this;\n  };\n\n  FakeTimeout.prototype.unref = function () {\n    return this;\n  };\n\n  return Clock;\n};\n\ngetJasmineRequireObj().DelayedFunctionScheduler = function(j$) {\n  function DelayedFunctionScheduler() {\n    var self = this;\n    var scheduledLookup = [];\n    var scheduledFunctions = {};\n    var currentTime = 0;\n    var delayedFnCount = 0;\n    var deletedKeys = [];\n\n    self.tick = function(millis, tickDate) {\n      millis = millis || 0;\n      var endTime = currentTime + millis;\n\n      runScheduledFunctions(endTime, tickDate);\n      currentTime = endTime;\n    };\n\n    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\n      var f;\n      if (typeof(funcToCall) === 'string') {\n        /* jshint evil: true */\n        f = function() { return eval(funcToCall); };\n        /* jshint evil: false */\n      } else {\n        f = funcToCall;\n      }\n\n      millis = millis || 0;\n      timeoutKey = timeoutKey || ++delayedFnCount;\n      runAtMillis = runAtMillis || (currentTime + millis);\n\n      var funcToSchedule = {\n        runAtMillis: runAtMillis,\n        funcToCall: f,\n        recurring: recurring,\n        params: params,\n        timeoutKey: timeoutKey,\n        millis: millis\n      };\n\n      if (runAtMillis in scheduledFunctions) {\n        scheduledFunctions[runAtMillis].push(funcToSchedule);\n      } else {\n        scheduledFunctions[runAtMillis] = [funcToSchedule];\n        scheduledLookup.push(runAtMillis);\n        scheduledLookup.sort(function (a, b) {\n          return a - b;\n        });\n      }\n\n      return timeoutKey;\n    };\n\n    self.removeFunctionWithId = function(timeoutKey) {\n      deletedKeys.push(timeoutKey);\n\n      for (var runAtMillis in scheduledFunctions) {\n        var funcs = scheduledFunctions[runAtMillis];\n        var i = indexOfFirstToPass(funcs, function (func) {\n          return func.timeoutKey === timeoutKey;\n        });\n\n        if (i > -1) {\n          if (funcs.length === 1) {\n            delete scheduledFunctions[runAtMillis];\n            deleteFromLookup(runAtMillis);\n          } else {\n            funcs.splice(i, 1);\n          }\n\n          // intervals get rescheduled when executed, so there's never more\n          // than a single scheduled function with a given timeoutKey\n          break;\n        }\n      }\n    };\n\n    return self;\n\n    function indexOfFirstToPass(array, testFn) {\n      var index = -1;\n\n      for (var i = 0; i < array.length; ++i) {\n        if (testFn(array[i])) {\n          index = i;\n          break;\n        }\n      }\n\n      return index;\n    }\n\n    function deleteFromLookup(key) {\n      var value = Number(key);\n      var i = indexOfFirstToPass(scheduledLookup, function (millis) {\n        return millis === value;\n      });\n\n      if (i > -1) {\n        scheduledLookup.splice(i, 1);\n      }\n    }\n\n    function reschedule(scheduledFn) {\n      self.scheduleFunction(scheduledFn.funcToCall,\n        scheduledFn.millis,\n        scheduledFn.params,\n        true,\n        scheduledFn.timeoutKey,\n        scheduledFn.runAtMillis + scheduledFn.millis);\n    }\n\n    function forEachFunction(funcsToRun, callback) {\n      for (var i = 0; i < funcsToRun.length; ++i) {\n        callback(funcsToRun[i]);\n      }\n    }\n\n    function runScheduledFunctions(endTime, tickDate) {\n      tickDate = tickDate || function() {};\n      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\n        tickDate(endTime - currentTime);\n        return;\n      }\n\n      do {\n        deletedKeys = [];\n        var newCurrentTime = scheduledLookup.shift();\n        tickDate(newCurrentTime - currentTime);\n\n        currentTime = newCurrentTime;\n\n        var funcsToRun = scheduledFunctions[currentTime];\n\n        delete scheduledFunctions[currentTime];\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          if (funcToRun.recurring) {\n            reschedule(funcToRun);\n          }\n        });\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          if (j$.util.arrayContains(deletedKeys, funcToRun.timeoutKey)) {\n            // skip a timeoutKey deleted whilst we were running\n            return;\n          }\n          funcToRun.funcToCall.apply(null, funcToRun.params || []);\n        });\n        deletedKeys = [];\n      } while (scheduledLookup.length > 0 &&\n              // checking first if we're out of time prevents setTimeout(0)\n              // scheduled in a funcToRun from forcing an extra iteration\n                 currentTime !== endTime  &&\n                 scheduledLookup[0] <= endTime);\n\n      // ran out of functions to call, but still time left on the clock\n      if (currentTime !== endTime) {\n        tickDate(endTime - currentTime);\n      }\n    }\n  }\n\n  return DelayedFunctionScheduler;\n};\n\ngetJasmineRequireObj().errors = function() {\n  function ExpectationFailed() {}\n\n  ExpectationFailed.prototype = new Error();\n  ExpectationFailed.prototype.constructor = ExpectationFailed;\n\n  return {\n    ExpectationFailed: ExpectationFailed\n  };\n};\ngetJasmineRequireObj().ExceptionFormatter = function(j$) {\n\n  function ExceptionFormatter(options) {\n    var jasmineFile = (options && options.jasmineFile) || j$.util.jasmineFile();\n    this.message = function(error) {\n      var message = '';\n\n      if (error.name && error.message) {\n        message += error.name + ': ' + error.message;\n      } else {\n        message += error.toString() + ' thrown';\n      }\n\n      if (error.fileName || error.sourceURL) {\n        message += ' in ' + (error.fileName || error.sourceURL);\n      }\n\n      if (error.line || error.lineNumber) {\n        message += ' (line ' + (error.line || error.lineNumber) + ')';\n      }\n\n      return message;\n    };\n\n    this.stack = function(error) {\n      if (!error || !error.stack) {\n        return null;\n      }\n\n      var stackTrace = new j$.StackTrace(error.stack);\n      var lines = filterJasmine(stackTrace);\n      var result = '';\n\n      if (stackTrace.message) {\n        lines.unshift(stackTrace.message);\n      }\n\n      result += formatProperties(error);\n      result += lines.join('\\n');\n\n      return result;\n    };\n\n    function filterJasmine(stackTrace) {\n      var result = [],\n        jasmineMarker = stackTrace.style === 'webkit' ? '<Jasmine>' : '    at <Jasmine>';\n\n      stackTrace.frames.forEach(function(frame) {\n        if (frame.file && frame.file !== jasmineFile) {\n          result.push(frame.raw);\n        } else if (result[result.length - 1] !== jasmineMarker) {\n          result.push(jasmineMarker);\n        }\n      });\n\n      return result;\n    }\n\n    function formatProperties(error) {\n      if (!(error instanceof Object)) {\n        return;\n      }\n\n      var ignored = ['name', 'message', 'stack', 'fileName', 'sourceURL', 'line', 'lineNumber', 'column', 'description'];\n      var result = {};\n      var empty = true;\n\n      for (var prop in error) {\n        if (j$.util.arrayContains(ignored, prop)) {\n          continue;\n        }\n        result[prop] = error[prop];\n        empty = false;\n      }\n\n      if (!empty) {\n        return 'error properties: ' + j$.pp(result) + '\\n';\n      }\n\n      return '';\n    }\n  }\n\n  return ExceptionFormatter;\n};\n\ngetJasmineRequireObj().Expectation = function() {\n\n  /**\n   * Matchers that come with Jasmine out of the box.\n   * @namespace matchers\n   */\n  function Expectation(options) {\n    this.util = options.util || { buildFailureMessage: function() {} };\n    this.customEqualityTesters = options.customEqualityTesters || [];\n    this.actual = options.actual;\n    this.addExpectationResult = options.addExpectationResult || function(){};\n    this.isNot = options.isNot;\n\n    var customMatchers = options.customMatchers || {};\n    for (var matcherName in customMatchers) {\n      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);\n    }\n  }\n\n  Expectation.prototype.wrapCompare = function(name, matcherFactory) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        expected = args.slice(0),\n        message = '';\n\n      args.unshift(this.actual);\n\n      var matcher = matcherFactory(this.util, this.customEqualityTesters),\n          matcherCompare = matcher.compare;\n\n      function defaultNegativeCompare() {\n        var result = matcher.compare.apply(null, args);\n        result.pass = !result.pass;\n        return result;\n      }\n\n      if (this.isNot) {\n        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\n      }\n\n      var result = matcherCompare.apply(null, args);\n\n      if (!result.pass) {\n        if (!result.message) {\n          args.unshift(this.isNot);\n          args.unshift(name);\n          message = this.util.buildFailureMessage.apply(null, args);\n        } else {\n          if (Object.prototype.toString.apply(result.message) === '[object Function]') {\n            message = result.message();\n          } else {\n            message = result.message;\n          }\n        }\n      }\n\n      if (expected.length == 1) {\n        expected = expected[0];\n      }\n\n      // TODO: how many of these params are needed?\n      this.addExpectationResult(\n        result.pass,\n        {\n          matcherName: name,\n          passed: result.pass,\n          message: message,\n          error: result.error,\n          actual: this.actual,\n          expected: expected // TODO: this may need to be arrayified/sliced\n        }\n      );\n    };\n  };\n\n  Expectation.addCoreMatchers = function(matchers) {\n    var prototype = Expectation.prototype;\n    for (var matcherName in matchers) {\n      var matcher = matchers[matcherName];\n      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\n    }\n  };\n\n  Expectation.Factory = function(options) {\n    options = options || {};\n\n    var expect = new Expectation(options);\n\n    // TODO: this would be nice as its own Object - NegativeExpectation\n    // TODO: copy instead of mutate options\n    options.isNot = true;\n    expect.not = new Expectation(options);\n\n    return expect;\n  };\n\n  return Expectation;\n};\n\n//TODO: expectation result may make more sense as a presentation of an expectation.\ngetJasmineRequireObj().buildExpectationResult = function() {\n  function buildExpectationResult(options) {\n    var messageFormatter = options.messageFormatter || function() {},\n      stackFormatter = options.stackFormatter || function() {};\n\n    /**\n     * @typedef Expectation\n     * @property {String} matcherName - The name of the matcher that was executed for this expectation.\n     * @property {String} message - The failure message for the expectation.\n     * @property {String} stack - The stack trace for the failure if available.\n     * @property {Boolean} passed - Whether the expectation passed or failed.\n     * @property {Object} expected - If the expectation failed, what was the expected value.\n     * @property {Object} actual - If the expectation failed, what actual value was produced.\n     */\n    var result = {\n      matcherName: options.matcherName,\n      message: message(),\n      stack: stack(),\n      passed: options.passed\n    };\n\n    if(!result.passed) {\n      result.expected = options.expected;\n      result.actual = options.actual;\n    }\n\n    return result;\n\n    function message() {\n      if (options.passed) {\n        return 'Passed.';\n      } else if (options.message) {\n        return options.message;\n      } else if (options.error) {\n        return messageFormatter(options.error);\n      }\n      return '';\n    }\n\n    function stack() {\n      if (options.passed) {\n        return '';\n      }\n\n      var error = options.error;\n      if (!error) {\n        if (options.stack) {\n          error = options;\n        } else {\n          try {\n            throw new Error(message());\n          } catch (e) {\n            error = e;\n          }\n        }\n      }\n      return stackFormatter(error);\n    }\n  }\n\n  return buildExpectationResult;\n};\n\ngetJasmineRequireObj().formatErrorMsg = function() {\n  function generateErrorMsg(domain, usage) {\n    var usageDefinition = usage ? '\\nUsage: ' + usage : '';\n\n    return function errorMsg(msg) {\n      return domain + ' : ' + msg + usageDefinition;\n    };\n  }\n\n  return generateErrorMsg;\n};\n\ngetJasmineRequireObj().GlobalErrors = function(j$) {\n  function GlobalErrors(global) {\n    var handlers = [];\n    global = global || j$.getGlobal();\n\n    var onerror = function onerror() {\n      var handler = handlers[handlers.length - 1];\n\n      if (handler) {\n        handler.apply(null, Array.prototype.slice.call(arguments, 0));\n      } else {\n        throw arguments[0];\n      }\n    };\n\n    this.install = function install() {\n      if (global.process && global.process.listeners && j$.isFunction_(global.process.on)) {\n        var originalHandlers = global.process.listeners('uncaughtException');\n        global.process.removeAllListeners('uncaughtException');\n        global.process.on('uncaughtException', onerror);\n\n        this.uninstall = function uninstall() {\n          global.process.removeListener('uncaughtException', onerror);\n          for (var i = 0; i < originalHandlers.length; i++) {\n            global.process.on('uncaughtException', originalHandlers[i]);\n          }\n        };\n      } else {\n        var originalHandler = global.onerror;\n        global.onerror = onerror;\n\n        this.uninstall = function uninstall() {\n          global.onerror = originalHandler;\n        };\n      }\n    };\n\n    this.pushListener = function pushListener(listener) {\n      handlers.push(listener);\n    };\n\n    this.popListener = function popListener() {\n      handlers.pop();\n    };\n  }\n\n  return GlobalErrors;\n};\n\ngetJasmineRequireObj().DiffBuilder = function(j$) {\n  return function DiffBuilder() {\n    var path = new j$.ObjectPath(),\n        mismatches = [];\n\n    return {\n      record: function (actual, expected, formatter) {\n        formatter = formatter || defaultFormatter;\n        mismatches.push(formatter(actual, expected, path));\n      },\n\n      getMessage: function () {\n        return mismatches.join('\\n');\n      },\n\n      withPath: function (pathComponent, block) {\n        var oldPath = path;\n        path = path.add(pathComponent);\n        block();\n        path = oldPath;\n      }\n    };\n\n    function defaultFormatter (actual, expected, path) {\n      return 'Expected ' +\n        path + (path.depth() ? ' = ' : '') +\n        j$.pp(actual) +\n        ' to equal ' +\n        j$.pp(expected) +\n        '.';\n    }\n  };\n};\n\ngetJasmineRequireObj().matchersUtil = function(j$) {\n  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\n\n  return {\n    equals: equals,\n\n    contains: function(haystack, needle, customTesters) {\n      customTesters = customTesters || [];\n\n      if ((Object.prototype.toString.apply(haystack) === '[object Set]')) {\n        return haystack.has(needle);\n      }\n\n      if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\n        (!!haystack && !haystack.indexOf))\n      {\n        for (var i = 0; i < haystack.length; i++) {\n          if (equals(haystack[i], needle, customTesters)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      return !!haystack && haystack.indexOf(needle) >= 0;\n    },\n\n    buildFailureMessage: function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        matcherName = args[0],\n        isNot = args[1],\n        actual = args[2],\n        expected = args.slice(3),\n        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\n\n      var message = 'Expected ' +\n        j$.pp(actual) +\n        (isNot ? ' not ' : ' ') +\n        englishyPredicate;\n\n      if (expected.length > 0) {\n        for (var i = 0; i < expected.length; i++) {\n          if (i > 0) {\n            message += ',';\n          }\n          message += ' ' + j$.pp(expected[i]);\n        }\n      }\n\n      return message + '.';\n    }\n  };\n\n  function isAsymmetric(obj) {\n    return obj && j$.isA_('Function', obj.asymmetricMatch);\n  }\n\n  function asymmetricMatch(a, b, customTesters, diffBuilder) {\n    var asymmetricA = isAsymmetric(a),\n        asymmetricB = isAsymmetric(b),\n        result;\n\n    if (asymmetricA && asymmetricB) {\n      return undefined;\n    }\n\n    if (asymmetricA) {\n      result = a.asymmetricMatch(b, customTesters);\n      if (!result) {\n        diffBuilder.record(a, b);\n      }\n      return result;\n    }\n\n    if (asymmetricB) {\n      result = b.asymmetricMatch(a, customTesters);\n      if (!result) {\n        diffBuilder.record(a, b);\n      }\n      return result;\n    }\n  }\n\n  function equals(a, b, customTesters, diffBuilder) {\n    customTesters = customTesters || [];\n    diffBuilder = diffBuilder || j$.NullDiffBuilder();\n\n    return eq(a, b, [], [], customTesters, diffBuilder);\n  }\n\n  // Equality function lovingly adapted from isEqual in\n  //   [Underscore](http://underscorejs.org)\n  function eq(a, b, aStack, bStack, customTesters, diffBuilder) {\n    var result = true, i;\n\n    var asymmetricResult = asymmetricMatch(a, b, customTesters, diffBuilder);\n    if (!j$.util.isUndefined(asymmetricResult)) {\n      return asymmetricResult;\n    }\n\n    for (i = 0; i < customTesters.length; i++) {\n      var customTesterResult = customTesters[i](a, b);\n      if (!j$.util.isUndefined(customTesterResult)) {\n        if (!customTesterResult) {\n          diffBuilder.record(a, b);\n        }\n        return customTesterResult;\n      }\n    }\n\n    if (a instanceof Error && b instanceof Error) {\n      result = a.message == b.message;\n      if (!result) {\n        diffBuilder.record(a, b);\n      }\n      return result;\n    }\n\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) {\n      result = a !== 0 || 1 / a == 1 / b;\n      if (!result) {\n        diffBuilder.record(a, b);\n      }\n      return result;\n    }\n    // A strict comparison is necessary because `null == undefined`.\n    if (a === null || b === null) {\n      result = a === b;\n      if (!result) {\n        diffBuilder.record(a, b);\n      }\n      return result;\n    }\n    var className = Object.prototype.toString.call(a);\n    if (className != Object.prototype.toString.call(b)) {\n      diffBuilder.record(a, b);\n      return false;\n    }\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        result = a == String(b);\n        if (!result) {\n          diffBuilder.record(a, b);\n        }\n        return result;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        result = a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\n        if (!result) {\n          diffBuilder.record(a, b);\n        }\n        return result;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        result = +a == +b;\n        if (!result) {\n          diffBuilder.record(a, b);\n        }\n        return result;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n          a.global == b.global &&\n          a.multiline == b.multiline &&\n          a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') {\n      diffBuilder.record(a, b);\n      return false;\n    }\n\n    var aIsDomNode = j$.isDomNode(a);\n    var bIsDomNode = j$.isDomNode(b);\n    if (aIsDomNode && bIsDomNode) {\n      // At first try to use DOM3 method isEqualNode\n      result = a.isEqualNode(b);\n      if (!result) {\n        diffBuilder.record(a, b);\n      }\n      return result;\n    }\n    if (aIsDomNode || bIsDomNode) {\n      diffBuilder.record(a, b);\n      return false;\n    }\n\n    var aIsPromise = j$.isPromise(a);\n    var bIsPromise = j$.isPromise(b);\n    if (aIsPromise && bIsPromise) {\n      return a === b;\n    }\n\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) { return bStack[length] == b; }\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0;\n    // Recursively compare objects and arrays.\n    // Compare array lengths to determine if a deep comparison is necessary.\n    if (className == '[object Array]') {\n      var aLength = a.length;\n      var bLength = b.length;\n\n      diffBuilder.withPath('length', function() {\n        if (aLength !== bLength) {\n          diffBuilder.record(aLength, bLength);\n          result = false;\n        }\n      });\n\n      for (i = 0; i < aLength || i < bLength; i++) {\n        diffBuilder.withPath(i, function() {\n          result = eq(i < aLength ? a[i] : void 0, i < bLength ? b[i] : void 0, aStack, bStack, customTesters, diffBuilder) && result;\n        });\n      }\n      if (!result) {\n        return false;\n      }\n    } else if (j$.isMap(a) && j$.isMap(b)) {\n      if (a.size != b.size) {\n        diffBuilder.record(a, b);\n        return false;\n      }\n\n      var keysA = [];\n      var keysB = [];\n      a.forEach( function( valueA, keyA ) {\n        keysA.push( keyA );\n      });\n      b.forEach( function( valueB, keyB ) {\n        keysB.push( keyB );\n      });\n\n      // For both sets of keys, check they map to equal values in both maps.\n      // Keep track of corresponding keys (in insertion order) in order to handle asymmetric obj keys.\n      var mapKeys = [keysA, keysB];\n      var cmpKeys = [keysB, keysA];\n      var mapIter, mapKey, mapValueA, mapValueB;\n      var cmpIter, cmpKey;\n      for (i = 0; result && i < mapKeys.length; i++) {\n        mapIter = mapKeys[i];\n        cmpIter = cmpKeys[i];\n\n        for (var j = 0; result && j < mapIter.length; j++) {\n          mapKey = mapIter[j];\n          cmpKey = cmpIter[j];\n          mapValueA = a.get(mapKey);\n\n          // Only use the cmpKey when one of the keys is asymmetric and the corresponding key matches,\n          // otherwise explicitly look up the mapKey in the other Map since we want keys with unique\n          // obj identity (that are otherwise equal) to not match.\n          if (isAsymmetric(mapKey) || isAsymmetric(cmpKey) &&\n              eq(mapKey, cmpKey, aStack, bStack, customTesters, j$.NullDiffBuilder())) {\n            mapValueB = b.get(cmpKey);\n          } else {\n            mapValueB = b.get(mapKey);\n          }\n          result = eq(mapValueA, mapValueB, aStack, bStack, customTesters, j$.NullDiffBuilder());\n        }\n      }\n\n      if (!result) {\n        diffBuilder.record(a, b);\n        return false;\n      }\n    } else if (j$.isSet(a) && j$.isSet(b)) {\n      if (a.size != b.size) {\n        diffBuilder.record(a, b);\n        return false;\n      }\n\n      var valuesA = [];\n      a.forEach( function( valueA ) {\n        valuesA.push( valueA );\n      });\n      var valuesB = [];\n      b.forEach( function( valueB ) {\n        valuesB.push( valueB );\n      });\n\n      // For both sets, check they are all contained in the other set\n      var setPairs = [[valuesA, valuesB], [valuesB, valuesA]];\n      var stackPairs = [[aStack, bStack], [bStack, aStack]];\n      var baseValues, baseValue, baseStack;\n      var otherValues, otherValue, otherStack;\n      var found;\n      var prevStackSize;\n      for (i = 0; result && i < setPairs.length; i++) {\n        baseValues = setPairs[i][0];\n        otherValues = setPairs[i][1];\n        baseStack = stackPairs[i][0];\n        otherStack = stackPairs[i][1];\n        // For each value in the base set...\n        for (var k = 0; result && k < baseValues.length; k++) {\n          baseValue = baseValues[k];\n          found = false;\n          // ... test that it is present in the other set\n          for (var l = 0; !found && l < otherValues.length; l++) {\n            otherValue = otherValues[l];\n            prevStackSize = baseStack.length;\n            // compare by value equality\n            found = eq(baseValue, otherValue, baseStack, otherStack, customTesters, j$.NullDiffBuilder());\n            if (!found && prevStackSize !== baseStack.length) {\n              baseStack.splice(prevStackSize);\n              otherStack.splice(prevStackSize);\n            }\n          }\n          result = result && found;\n        }\n      }\n\n      if (!result) {\n        diffBuilder.record(a, b);\n        return false;\n      }\n    } else {\n\n      // Objects with different constructors are not equivalent, but `Object`s\n      // or `Array`s from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor &&\n          isFunction(aCtor) && isFunction(bCtor) &&\n          a instanceof aCtor && b instanceof bCtor &&\n          !(aCtor instanceof aCtor && bCtor instanceof bCtor)) {\n\n        diffBuilder.record(a, b, constructorsAreDifferentFormatter);\n        return false;\n      }\n    }\n\n    // Deep compare objects.\n    var aKeys = keys(a, className == '[object Array]'), key;\n    size = aKeys.length;\n\n    // Ensure that both objects contain the same number of properties before comparing deep equality.\n    if (keys(b, className == '[object Array]').length !== size) {\n      diffBuilder.record(a, b, objectKeysAreDifferentFormatter);\n      return false;\n    }\n\n    for (i = 0; i < size; i++) {\n      key = aKeys[i];\n      // Deep compare each member\n      if (!j$.util.has(b, key)) {\n        diffBuilder.record(a, b, objectKeysAreDifferentFormatter);\n        result = false;\n        continue;\n      }\n\n      diffBuilder.withPath(key, function() {\n        if(!eq(a[key], b[key], aStack, bStack, customTesters, diffBuilder)) {\n          result = false;\n        }\n      });\n    }\n\n    if (!result) {\n      return false;\n    }\n\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n\n    return result;\n  }\n\n  function keys(obj, isArray) {\n    var allKeys = Object.keys ? Object.keys(obj) :\n      (function(o) {\n          var keys = [];\n          for (var key in o) {\n              if (j$.util.has(o, key)) {\n                  keys.push(key);\n              }\n          }\n          return keys;\n      })(obj);\n\n    if (!isArray) {\n      return allKeys;\n    }\n\n    if (allKeys.length === 0) {\n        return allKeys;\n    }\n\n    var extraKeys = [];\n    for (var i = 0; i < allKeys.length; i++) {\n      if (!/^[0-9]+$/.test(allKeys[i])) {\n        extraKeys.push(allKeys[i]);\n      }\n    }\n\n    return extraKeys;\n  }\n\n  function has(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  }\n\n  function isFunction(obj) {\n    return typeof obj === 'function';\n  }\n\n  function objectKeysAreDifferentFormatter(actual, expected, path) {\n    var missingProperties = j$.util.objectDifference(expected, actual),\n        extraProperties = j$.util.objectDifference(actual, expected),\n        missingPropertiesMessage = formatKeyValuePairs(missingProperties),\n        extraPropertiesMessage = formatKeyValuePairs(extraProperties),\n        messages = [];\n\n    if (!path.depth()) {\n      path = 'object';\n    }\n\n    if (missingPropertiesMessage.length) {\n      messages.push('Expected ' + path + ' to have properties' + missingPropertiesMessage);\n    }\n\n    if (extraPropertiesMessage.length) {\n      messages.push('Expected ' + path + ' not to have properties' + extraPropertiesMessage);\n    }\n\n    return messages.join('\\n');\n  }\n\n  function constructorsAreDifferentFormatter(actual, expected, path) {\n    if (!path.depth()) {\n      path = 'object';\n    }\n\n    return 'Expected ' +\n      path + ' to be a kind of ' +\n      j$.fnNameFor(expected.constructor) +\n      ', but was ' + j$.pp(actual) + '.';\n  }\n\n  function formatKeyValuePairs(obj) {\n    var formatted = '';\n    for (var key in obj) {\n      formatted += '\\n    ' + key + ': ' + j$.pp(obj[key]);\n    }\n    return formatted;\n  }\n};\n\ngetJasmineRequireObj().nothing = function() {\n  /**\n   * {@link expect} nothing explicitly.\n   * @function\n   * @name matchers#nothing\n   * @example\n   * expect().nothing();\n   */\n  function nothing() {\n    return {\n      compare: function() {\n        return {\n          pass: true\n        };\n      }\n    };\n  }\n\n  return nothing;\n};\n\ngetJasmineRequireObj().NullDiffBuilder = function(j$) {\n  return function() {\n    return {\n      withPath: function(_, block) {\n        block();\n      },\n      record: function() {}\n    };\n  };\n};\n\ngetJasmineRequireObj().ObjectPath = function(j$) {\n  function ObjectPath(components) {\n    this.components = components || [];\n  }\n\n  ObjectPath.prototype.toString = function() {\n    if (this.components.length) {\n      return '$' + map(this.components, formatPropertyAccess).join('');\n    } else {\n      return '';\n    }\n  };\n\n  ObjectPath.prototype.add = function(component) {\n    return new ObjectPath(this.components.concat([component]));\n  };\n\n  ObjectPath.prototype.depth = function() {\n    return this.components.length;\n  };\n\n  function formatPropertyAccess(prop) {\n    if (typeof prop === 'number') {\n      return '[' + prop + ']';\n    }\n\n    if (isValidIdentifier(prop)) {\n      return '.' + prop;\n    }\n\n    return '[\\'' + prop + '\\']';\n  }\n\n  function map(array, fn) {\n    var results = [];\n    for (var i = 0; i < array.length; i++) {\n      results.push(fn(array[i]));\n    }\n    return results;\n  }\n\n  function isValidIdentifier(string) {\n    return /^[A-Za-z\\$_][A-Za-z0-9\\$_]*$/.test(string);\n  }\n\n  return ObjectPath;\n};\n\ngetJasmineRequireObj().toBe = function() {\n  /**\n   * {@link expect} the actual value to be `===` to the expected value.\n   * @function\n   * @name matchers#toBe\n   * @param {Object} expected - The expected value to compare against.\n   * @example\n   * expect(thing).toBe(realThing);\n   */\n  function toBe() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual === expected\n        };\n      }\n    };\n  }\n\n  return toBe;\n};\n\ngetJasmineRequireObj().toBeCloseTo = function() {\n  /**\n   * {@link expect} the actual value to be within a specified precision of the expected value.\n   * @function\n   * @name matchers#toBeCloseTo\n   * @param {Object} expected - The expected value to compare against.\n   * @param {Number} [precision=2] - The number of decimal points to check.\n   * @example\n   * expect(number).toBeCloseTo(42.2, 3);\n   */\n  function toBeCloseTo() {\n    return {\n      compare: function(actual, expected, precision) {\n        if (precision !== 0) {\n          precision = precision || 2;\n        }\n\n        if (expected === null || actual === null) {\n          throw new Error('Cannot use toBeCloseTo with null. Arguments evaluated to: ' +\n            'expect(' + actual + ').toBeCloseTo(' + expected + ').'\n          );\n        }\n\n        var pow = Math.pow(10, precision + 1);\n        var delta = Math.abs(expected - actual);\n        var maxDelta = Math.pow(10, -precision) / 2;\n\n        return {\n          pass: Math.round(delta * pow) / pow <= maxDelta\n        };\n      }\n    };\n  }\n\n  return toBeCloseTo;\n};\n\ngetJasmineRequireObj().toBeDefined = function() {\n  /**\n   * {@link expect} the actual value to be defined. (Not `undefined`)\n   * @function\n   * @name matchers#toBeDefined\n   * @example\n   * expect(result).toBeDefined();\n   */\n  function toBeDefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: (void 0 !== actual)\n        };\n      }\n    };\n  }\n\n  return toBeDefined;\n};\n\ngetJasmineRequireObj().toBeFalsy = function() {\n  /**\n   * {@link expect} the actual value to be falsy\n   * @function\n   * @name matchers#toBeFalsy\n   * @example\n   * expect(result).toBeFalsy();\n   */\n  function toBeFalsy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!!actual\n        };\n      }\n    };\n  }\n\n  return toBeFalsy;\n};\n\ngetJasmineRequireObj().toBeGreaterThan = function() {\n  /**\n   * {@link expect} the actual value to be greater than the expected value.\n   * @function\n   * @name matchers#toBeGreaterThan\n   * @param {Number} expected - The value to compare against.\n   * @example\n   * expect(result).toBeGreaterThan(3);\n   */\n  function toBeGreaterThan() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual > expected\n        };\n      }\n    };\n  }\n\n  return toBeGreaterThan;\n};\n\n\ngetJasmineRequireObj().toBeGreaterThanOrEqual = function() {\n  /**\n   * {@link expect} the actual value to be greater than or equal to the expected value.\n   * @function\n   * @name matchers#toBeGreaterThanOrEqual\n   * @param {Number} expected - The expected value to compare against.\n   * @example\n   * expect(result).toBeGreaterThanOrEqual(25);\n   */\n  function toBeGreaterThanOrEqual() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual >= expected\n        };\n      }\n    };\n  }\n\n  return toBeGreaterThanOrEqual;\n};\n\ngetJasmineRequireObj().toBeLessThan = function() {\n  /**\n   * {@link expect} the actual value to be less than the expected value.\n   * @function\n   * @name matchers#toBeLessThan\n   * @param {Number} expected - The expected value to compare against.\n   * @example\n   * expect(result).toBeLessThan(0);\n   */\n  function toBeLessThan() {\n    return {\n\n      compare: function(actual, expected) {\n        return {\n          pass: actual < expected\n        };\n      }\n    };\n  }\n\n  return toBeLessThan;\n};\n\ngetJasmineRequireObj().toBeLessThanOrEqual = function() {\n  /**\n   * {@link expect} the actual value to be less than or equal to the expected value.\n   * @function\n   * @name matchers#toBeLessThanOrEqual\n   * @param {Number} expected - The expected value to compare against.\n   * @example\n   * expect(result).toBeLessThanOrEqual(123);\n   */\n  function toBeLessThanOrEqual() {\n    return {\n\n      compare: function(actual, expected) {\n        return {\n          pass: actual <= expected\n        };\n      }\n    };\n  }\n\n  return toBeLessThanOrEqual;\n};\n\ngetJasmineRequireObj().toBeNaN = function(j$) {\n  /**\n   * {@link expect} the actual value to be `NaN` (Not a Number).\n   * @function\n   * @name matchers#toBeNaN\n   * @example\n   * expect(thing).toBeNaN();\n   */\n  function toBeNaN() {\n    return {\n      compare: function(actual) {\n        var result = {\n          pass: (actual !== actual)\n        };\n\n        if (result.pass) {\n          result.message = 'Expected actual not to be NaN.';\n        } else {\n          result.message = function() { return 'Expected ' + j$.pp(actual) + ' to be NaN.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toBeNaN;\n};\n\ngetJasmineRequireObj().toBeNegativeInfinity = function(j$) {\n  /**\n   * {@link expect} the actual value to be `-Infinity` (-infinity).\n   * @function\n   * @name matchers#toBeNegativeInfinity\n   * @example\n   * expect(thing).toBeNegativeInfinity();\n   */\n  function toBeNegativeInfinity() {\n    return {\n      compare: function(actual) {\n        var result = {\n          pass: (actual === Number.NEGATIVE_INFINITY)\n        };\n\n        if (result.pass) {\n          result.message = 'Expected actual to be -Infinity.';\n        } else {\n          result.message = function() { return 'Expected ' + j$.pp(actual) + ' not to be -Infinity.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toBeNegativeInfinity;\n};\n\ngetJasmineRequireObj().toBeNull = function() {\n  /**\n   * {@link expect} the actual value to be `null`.\n   * @function\n   * @name matchers#toBeNull\n   * @example\n   * expect(result).toBeNull();\n   */\n  function toBeNull() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: actual === null\n        };\n      }\n    };\n  }\n\n  return toBeNull;\n};\n\ngetJasmineRequireObj().toBePositiveInfinity = function(j$) {\n  /**\n   * {@link expect} the actual value to be `Infinity` (infinity).\n   * @function\n   * @name matchers#toBePositiveInfinity\n   * @example\n   * expect(thing).toBePositiveInfinity();\n   */\n  function toBePositiveInfinity() {\n    return {\n      compare: function(actual) {\n        var result = {\n          pass: (actual === Number.POSITIVE_INFINITY)\n        };\n\n        if (result.pass) {\n          result.message = 'Expected actual to be Infinity.';\n        } else {\n          result.message = function() { return 'Expected ' + j$.pp(actual) + ' not to be Infinity.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toBePositiveInfinity;\n};\n\ngetJasmineRequireObj().toBeTruthy = function() {\n  /**\n   * {@link expect} the actual value to be truthy.\n   * @function\n   * @name matchers#toBeTruthy\n   * @example\n   * expect(thing).toBeTruthy();\n   */\n  function toBeTruthy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!actual\n        };\n      }\n    };\n  }\n\n  return toBeTruthy;\n};\n\ngetJasmineRequireObj().toBeUndefined = function() {\n  /**\n   * {@link expect} the actual value to be `undefined`.\n   * @function\n   * @name matchers#toBeUndefined\n   * @example\n   * expect(result).toBeUndefined():\n   */\n  function toBeUndefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: void 0 === actual\n        };\n      }\n    };\n  }\n\n  return toBeUndefined;\n};\n\ngetJasmineRequireObj().toContain = function() {\n  /**\n   * {@link expect} the actual value to contain a specific value.\n   * @function\n   * @name matchers#toContain\n   * @param {Object} expected - The value to look for.\n   * @example\n   * expect(array).toContain(anElement);\n   * expect(string).toContain(substring);\n   */\n  function toContain(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n\n        return {\n          pass: util.contains(actual, expected, customEqualityTesters)\n        };\n      }\n    };\n  }\n\n  return toContain;\n};\n\ngetJasmineRequireObj().toEqual = function(j$) {\n  /**\n   * {@link expect} the actual value to be equal to the expected, using deep equality comparison.\n   * @function\n   * @name matchers#toEqual\n   * @param {Object} expected - Expected value\n   * @example\n   * expect(bigObject).toEqual({\"foo\": ['bar', 'baz']});\n   */\n  function toEqual(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n        var result = {\n            pass: false\n          },\n          diffBuilder = j$.DiffBuilder();\n\n        result.pass = util.equals(actual, expected, customEqualityTesters, diffBuilder);\n\n        // TODO: only set error message if test fails\n        result.message = diffBuilder.getMessage();\n\n        return result;\n      }\n    };\n  }\n\n  return toEqual;\n};\n\ngetJasmineRequireObj().toHaveBeenCalled = function(j$) {\n\n  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalled>', 'expect(<spyObj>).toHaveBeenCalled()');\n\n  /**\n   * {@link expect} the actual (a {@link Spy}) to have been called.\n   * @function\n   * @name matchers#toHaveBeenCalled\n   * @example\n   * expect(mySpy).toHaveBeenCalled();\n   * expect(mySpy).not.toHaveBeenCalled();\n   */\n  function toHaveBeenCalled() {\n    return {\n      compare: function(actual) {\n        var result = {};\n\n        if (!j$.isSpy(actual)) {\n          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\n        }\n\n        if (arguments.length > 1) {\n          throw new Error(getErrorMsg('Does not take arguments, use toHaveBeenCalledWith'));\n        }\n\n        result.pass = actual.calls.any();\n\n        result.message = result.pass ?\n          'Expected spy ' + actual.and.identity + ' not to have been called.' :\n          'Expected spy ' + actual.and.identity + ' to have been called.';\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalled;\n};\n\ngetJasmineRequireObj().toHaveBeenCalledBefore = function(j$) {\n\n  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledBefore>', 'expect(<spyObj>).toHaveBeenCalledBefore(<spyObj>)');\n\n  /**\n   * {@link expect} the actual value (a {@link Spy}) to have been called before another {@link Spy}.\n   * @function\n   * @name matchers#toHaveBeenCalledBefore\n   * @param {Spy} expected - {@link Spy} that should have been called after the `actual` {@link Spy}.\n   * @example\n   * expect(mySpy).toHaveBeenCalledBefore(otherSpy);\n   */\n  function toHaveBeenCalledBefore() {\n    return {\n      compare: function(firstSpy, latterSpy) {\n        if (!j$.isSpy(firstSpy)) {\n          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(firstSpy) + '.'));\n        }\n        if (!j$.isSpy(latterSpy)) {\n          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(latterSpy) + '.'));\n        }\n\n        var result = { pass: false };\n\n        if (!firstSpy.calls.count()) {\n          result.message = 'Expected spy ' +  firstSpy.and.identity + ' to have been called.';\n          return result;\n        }\n        if (!latterSpy.calls.count()) {\n          result.message = 'Expected spy ' +  latterSpy.and.identity + ' to have been called.';\n          return result;\n        }\n\n        var latest1stSpyCall = firstSpy.calls.mostRecent().invocationOrder;\n        var first2ndSpyCall = latterSpy.calls.first().invocationOrder;\n\n        result.pass = latest1stSpyCall < first2ndSpyCall;\n\n        if (result.pass) {\n          result.message = 'Expected spy ' + firstSpy.and.identity + ' to not have been called before spy ' + latterSpy.and.identity + ', but it was';\n        } else {\n          var first1stSpyCall = firstSpy.calls.first().invocationOrder;\n          var latest2ndSpyCall = latterSpy.calls.mostRecent().invocationOrder;\n\n          if(first1stSpyCall < first2ndSpyCall) {\n            result.message = 'Expected latest call to spy ' + firstSpy.and.identity + ' to have been called before first call to spy ' + latterSpy.and.identity + ' (no interleaved calls)';\n          } else if (latest2ndSpyCall > latest1stSpyCall) {\n            result.message = 'Expected first call to spy ' + latterSpy.and.identity + ' to have been called after latest call to spy ' + firstSpy.and.identity + ' (no interleaved calls)';\n          } else {\n            result.message = 'Expected spy ' + firstSpy.and.identity + ' to have been called before spy ' + latterSpy.and.identity;\n          }\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalledBefore;\n};\n\ngetJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {\n\n  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledTimes>', 'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)');\n\n  /**\n   * {@link expect} the actual (a {@link Spy}) to have been called the specified number of times.\n   * @function\n   * @name matchers#toHaveBeenCalledTimes\n   * @param {Number} expected - The number of invocations to look for.\n   * @example\n   * expect(mySpy).toHaveBeenCalledTimes(3);\n   */\n  function toHaveBeenCalledTimes() {\n    return {\n      compare: function(actual, expected) {\n        if (!j$.isSpy(actual)) {\n          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\n        }\n\n        var args = Array.prototype.slice.call(arguments, 0),\n          result = { pass: false };\n\n        if (!j$.isNumber_(expected)){\n          throw new Error(getErrorMsg('The expected times failed is a required argument and must be a number.'));\n        }\n\n        actual = args[0];\n        var calls = actual.calls.count();\n        var timesMessage = expected === 1 ? 'once' : expected + ' times';\n        result.pass = calls === expected;\n        result.message = result.pass ?\n          'Expected spy ' + actual.and.identity + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :\n          'Expected spy ' + actual.and.identity + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalledTimes;\n};\n\ngetJasmineRequireObj().toHaveBeenCalledWith = function(j$) {\n\n  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledWith>', 'expect(<spyObj>).toHaveBeenCalledWith(...arguments)');\n\n  /**\n   * {@link expect} the actual (a {@link Spy}) to have been called with particular arguments at least once.\n   * @function\n   * @name matchers#toHaveBeenCalledWith\n   * @param {...Object} - The arguments to look for\n   * @example\n   * expect(mySpy).toHaveBeenCalledWith('foo', 'bar', 2);\n   */\n  function toHaveBeenCalledWith(util, customEqualityTesters) {\n    return {\n      compare: function() {\n        var args = Array.prototype.slice.call(arguments, 0),\n          actual = args[0],\n          expectedArgs = args.slice(1),\n          result = { pass: false };\n\n        if (!j$.isSpy(actual)) {\n          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\n        }\n\n        if (!actual.calls.any()) {\n          result.message = function() { return 'Expected spy ' + actual.and.identity + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };\n          return result;\n        }\n\n        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {\n          result.pass = true;\n          result.message = function() { return 'Expected spy ' + actual.and.identity + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };\n        } else {\n          result.message = function() { return 'Expected spy ' + actual.and.identity + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\\[ | \\]$/g, '') + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalledWith;\n};\n\ngetJasmineRequireObj().toHaveClass = function(j$) {\n  /**\n   * {@link expect} the actual value to be a DOM element that has the expected class\n   * @function\n   * @name matchers#toHaveClass\n   * @param {Object} expected - The class name to test for\n   * @example\n   * var el = document.createElement('div');\n   * el.className = 'foo bar baz';\n   * expect(el).toHaveClass('bar');\n   */\n  function toHaveClass(util, customEqualityTesters) {\n    return {\n      compare: function(actual, expected) {\n        if (!isElement(actual)) {\n          throw new Error(j$.pp(actual) + ' is not a DOM element');\n        }\n\n        return {\n          pass: actual.classList.contains(expected)\n        };\n      }\n    };\n  }\n\n  function isElement(maybeEl) {\n    return maybeEl &&\n      maybeEl.classList &&\n      j$.isFunction_(maybeEl.classList.contains);\n  }\n\n  return toHaveClass;\n};\n\ngetJasmineRequireObj().toMatch = function(j$) {\n\n  var getErrorMsg = j$.formatErrorMsg('<toMatch>', 'expect(<expectation>).toMatch(<string> || <regexp>)');\n\n  /**\n   * {@link expect} the actual value to match a regular expression\n   * @function\n   * @name matchers#toMatch\n   * @param {RegExp|String} expected - Value to look for in the string.\n   * @example\n   * expect(\"my string\").toMatch(/string$/);\n   * expect(\"other string\").toMatch(\"her\");\n   */\n  function toMatch() {\n    return {\n      compare: function(actual, expected) {\n        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n          throw new Error(getErrorMsg('Expected is not a String or a RegExp'));\n        }\n\n        var regexp = new RegExp(expected);\n\n        return {\n          pass: regexp.test(actual)\n        };\n      }\n    };\n  }\n\n  return toMatch;\n};\n\ngetJasmineRequireObj().toThrow = function(j$) {\n\n  var getErrorMsg = j$.formatErrorMsg('<toThrow>', 'expect(function() {<expectation>}).toThrow()');\n\n  /**\n   * {@link expect} a function to `throw` something.\n   * @function\n   * @name matchers#toThrow\n   * @param {Object} [expected] - Value that should be thrown. If not provided, simply the fact that something was thrown will be checked.\n   * @example\n   * expect(function() { return 'things'; }).toThrow('foo');\n   * expect(function() { return 'stuff'; }).toThrow();\n   */\n  function toThrow(util) {\n    return {\n      compare: function(actual, expected) {\n        var result = { pass: false },\n          threw = false,\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error(getErrorMsg('Actual is not a Function'));\n        }\n\n        try {\n          actual();\n        } catch (e) {\n          threw = true;\n          thrown = e;\n        }\n\n        if (!threw) {\n          result.message = 'Expected function to throw an exception.';\n          return result;\n        }\n\n        if (arguments.length == 1) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };\n\n          return result;\n        }\n\n        if (util.equals(thrown, expected)) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };\n        } else {\n          result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toThrow;\n};\n\ngetJasmineRequireObj().toThrowError = function(j$) {\n\n  var getErrorMsg =  j$.formatErrorMsg('<toThrowError>', 'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)');\n\n  /**\n   * {@link expect} a function to `throw` an `Error`.\n   * @function\n   * @name matchers#toThrowError\n   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.\n   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`\n   * @example\n   * expect(function() { return 'things'; }).toThrowError(MyCustomError, 'message');\n   * expect(function() { return 'things'; }).toThrowError(MyCustomError, /bar/);\n   * expect(function() { return 'stuff'; }).toThrowError(MyCustomError);\n   * expect(function() { return 'other'; }).toThrowError(/foo/);\n   * expect(function() { return 'other'; }).toThrowError();\n   */\n  function toThrowError () {\n    return {\n      compare: function(actual) {\n        var errorMatcher = getMatcher.apply(null, arguments),\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error(getErrorMsg('Actual is not a Function'));\n        }\n\n        try {\n          actual();\n          return fail('Expected function to throw an Error.');\n        } catch (e) {\n          thrown = e;\n        }\n\n        if (!j$.isError_(thrown)) {\n          return fail(function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; });\n        }\n\n        return errorMatcher.match(thrown);\n      }\n    };\n\n    function getMatcher() {\n      var expected, errorType;\n\n      if (arguments[2]) {\n        errorType = arguments[1];\n        expected = arguments[2];\n        if (!isAnErrorType(errorType)) {\n          throw new Error(getErrorMsg('Expected error type is not an Error.'));\n        }\n\n        return exactMatcher(expected, errorType);\n      } else if (arguments[1]) {\n        expected = arguments[1];\n\n        if (isAnErrorType(arguments[1])) {\n          return exactMatcher(null, arguments[1]);\n        } else {\n          return exactMatcher(arguments[1], null);\n        }\n      } else {\n        return anyMatcher();\n      }\n    }\n\n    function anyMatcher() {\n      return {\n        match: function(error) {\n          return pass('Expected function not to throw an Error, but it threw ' + j$.fnNameFor(error) + '.');\n        }\n      };\n    }\n\n    function exactMatcher(expected, errorType) {\n      if (expected && !isStringOrRegExp(expected)) {\n        if (errorType) {\n          throw new Error(getErrorMsg('Expected error message is not a string or RegExp.'));\n        } else {\n          throw new Error(getErrorMsg('Expected is not an Error, string, or RegExp.'));\n        }\n      }\n\n      function messageMatch(message) {\n        if (typeof expected == 'string') {\n          return expected == message;\n        } else {\n          return expected.test(message);\n        }\n      }\n\n      var errorTypeDescription = errorType ? j$.fnNameFor(errorType) : 'an exception';\n\n      function thrownDescription(thrown) {\n        var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\n            thrownMessage = '';\n\n        if (expected) {\n          thrownMessage = ' with message ' + j$.pp(thrown.message);\n        }\n\n        return thrownName + thrownMessage;\n      }\n\n      function messageDescription() {\n        if (expected === null) {\n          return '';\n        } else if (expected instanceof RegExp) {\n          return ' with a message matching ' + j$.pp(expected);\n        } else {\n          return ' with message ' + j$.pp(expected);\n        }\n      }\n\n      function matches(error) {\n        return (errorType === null || error instanceof errorType) &&\n          (expected === null || messageMatch(error.message));\n      }\n\n      return {\n        match: function(thrown) {\n          if (matches(thrown)) {\n            return pass(function() {\n              return 'Expected function not to throw ' + errorTypeDescription + messageDescription() + '.';\n            });\n          } else {\n            return fail(function() {\n              return 'Expected function to throw ' + errorTypeDescription + messageDescription() +\n                ', but it threw ' + thrownDescription(thrown) + '.';\n            });\n          }\n        }\n      };\n    }\n\n    function isStringOrRegExp(potential) {\n      return potential instanceof RegExp || (typeof potential == 'string');\n    }\n\n    function isAnErrorType(type) {\n      if (typeof type !== 'function') {\n        return false;\n      }\n\n      var Surrogate = function() {};\n      Surrogate.prototype = type.prototype;\n      return j$.isError_(new Surrogate());\n    }\n  }\n\n  function pass(message) {\n    return {\n      pass: true,\n      message: message\n    };\n  }\n\n  function fail(message) {\n    return {\n      pass: false,\n      message: message\n    };\n  }\n\n  return toThrowError;\n};\n\ngetJasmineRequireObj().toThrowMatching = function(j$) {\n  var usageError =  j$.formatErrorMsg('<toThrowMatching>', 'expect(function() {<expectation>}).toThrowMatching(<Predicate>)');\n\n  /**\n   * {@link expect} a function to `throw` something matching a predicate.\n   * @function\n   * @name matchers#toThrowMatching\n   * @param {Function} predicate - A function that takes the thrown exception as its parameter and returns true if it matches.\n   * @example\n   * expect(function() { throw new Error('nope'); }).toThrowMatching(function(thrown) { return thrown.message === 'nope'; });\n   */\n  function toThrowMatching() {\n    return {\n      compare: function(actual, predicate) {\n        var thrown;\n\n        if (typeof actual !== 'function') {\n          throw new Error(usageError('Actual is not a Function'));\n        }\n\n        if (typeof predicate !== 'function') {\n          throw new Error(usageError('Predicate is not a Function'));\n        }\n\n        try {\n          actual();\n          return fail('Expected function to throw an exception.');\n        } catch (e) {\n          thrown = e;\n        }\n\n        if (predicate(thrown)) {\n          return pass('Expected function not to throw an exception matching a predicate.');\n        } else {\n            return fail(function() {\n              return 'Expected function to throw an exception matching a predicate, ' +\n                'but it threw ' + thrownDescription(thrown) + '.';\n            });\n        }\n      }\n    };\n  }\n\n  function thrownDescription(thrown) {\n    if (thrown && thrown.constructor) {\n      return j$.fnNameFor(thrown.constructor) + ' with message ' +\n        j$.pp(thrown.message);\n    } else {\n      return j$.pp(thrown);\n    }\n  }\n\n  function pass(message) {\n    return {\n      pass: true,\n      message: message\n    };\n  }\n\n  function fail(message) {\n    return {\n      pass: false,\n      message: message\n    };\n  }\n\n  return toThrowMatching;\n};\n\ngetJasmineRequireObj().MockDate = function() {\n  function MockDate(global) {\n    var self = this;\n    var currentTime = 0;\n\n    if (!global || !global.Date) {\n      self.install = function() {};\n      self.tick = function() {};\n      self.uninstall = function() {};\n      return self;\n    }\n\n    var GlobalDate = global.Date;\n\n    self.install = function(mockDate) {\n      if (mockDate instanceof GlobalDate) {\n        currentTime = mockDate.getTime();\n      } else {\n        currentTime = new GlobalDate().getTime();\n      }\n\n      global.Date = FakeDate;\n    };\n\n    self.tick = function(millis) {\n      millis = millis || 0;\n      currentTime = currentTime + millis;\n    };\n\n    self.uninstall = function() {\n      currentTime = 0;\n      global.Date = GlobalDate;\n    };\n\n    createDateProperties();\n\n    return self;\n\n    function FakeDate() {\n      switch(arguments.length) {\n        case 0:\n          return new GlobalDate(currentTime);\n        case 1:\n          return new GlobalDate(arguments[0]);\n        case 2:\n          return new GlobalDate(arguments[0], arguments[1]);\n        case 3:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2]);\n        case 4:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);\n        case 5:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4]);\n        case 6:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5]);\n        default:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5], arguments[6]);\n      }\n    }\n\n    function createDateProperties() {\n      FakeDate.prototype = GlobalDate.prototype;\n\n      FakeDate.now = function() {\n        if (GlobalDate.now) {\n          return currentTime;\n        } else {\n          throw new Error('Browser does not support Date.now()');\n        }\n      };\n\n      FakeDate.toSource = GlobalDate.toSource;\n      FakeDate.toString = GlobalDate.toString;\n      FakeDate.parse = GlobalDate.parse;\n      FakeDate.UTC = GlobalDate.UTC;\n    }\n\t}\n\n  return MockDate;\n};\n\ngetJasmineRequireObj().pp = function(j$) {\n\n  function PrettyPrinter() {\n    this.ppNestLevel_ = 0;\n    this.seen = [];\n    this.length = 0;\n    this.stringParts = [];\n  }\n\n  function hasCustomToString(value) {\n    // value.toString !== Object.prototype.toString if value has no custom toString but is from another context (e.g.\n    // iframe, web worker)\n    return j$.isFunction_(value.toString) && value.toString !== Object.prototype.toString && (value.toString() !== Object.prototype.toString.call(value));\n  }\n\n  PrettyPrinter.prototype.format = function(value) {\n    this.ppNestLevel_++;\n    try {\n      if (j$.util.isUndefined(value)) {\n        this.emitScalar('undefined');\n      } else if (value === null) {\n        this.emitScalar('null');\n      } else if (value === 0 && 1/value === -Infinity) {\n        this.emitScalar('-0');\n      } else if (value === j$.getGlobal()) {\n        this.emitScalar('<global>');\n      } else if (value.jasmineToString) {\n        this.emitScalar(value.jasmineToString());\n      } else if (typeof value === 'string') {\n        this.emitString(value);\n      } else if (j$.isSpy(value)) {\n        this.emitScalar('spy on ' + value.and.identity);\n      } else if (value instanceof RegExp) {\n        this.emitScalar(value.toString());\n      } else if (typeof value === 'function') {\n        this.emitScalar('Function');\n      } else if (value.nodeType === 1) {\n        this.emitDomElement(value);\n      } else if (typeof value.nodeType === 'number') {\n        this.emitScalar('HTMLNode');\n      } else if (value instanceof Date) {\n        this.emitScalar('Date(' + value + ')');\n      } else if (j$.isSet(value)) {\n        this.emitSet(value);\n      } else if (j$.isMap(value)) {\n        this.emitMap(value);\n      } else if (j$.isTypedArray_(value)) {\n        this.emitTypedArray(value);\n      } else if (value.toString && typeof value === 'object' && !j$.isArray_(value) && hasCustomToString(value)) {\n        this.emitScalar(value.toString());\n      } else if (j$.util.arrayContains(this.seen, value)) {\n        this.emitScalar('<circular reference: ' + (j$.isArray_(value) ? 'Array' : 'Object') + '>');\n      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {\n        this.seen.push(value);\n        if (j$.isArray_(value)) {\n          this.emitArray(value);\n        } else {\n          this.emitObject(value);\n        }\n        this.seen.pop();\n      } else {\n        this.emitScalar(value.toString());\n      }\n    } catch (e) {\n      if (this.ppNestLevel_ > 1 || !(e instanceof MaxCharsReachedError)) {\n        throw e;\n      }\n    } finally {\n      this.ppNestLevel_--;\n    }\n  };\n\n  PrettyPrinter.prototype.iterateObject = function(obj, fn) {\n    var objKeys = keys(obj, j$.isArray_(obj));\n    var isGetter = function isGetter(prop) {};\n\n    if (obj.__lookupGetter__) {\n      isGetter = function isGetter(prop) {\n        var getter = obj.__lookupGetter__(prop);\n        return !j$.util.isUndefined(getter) && getter !== null;\n      };\n\n    }\n    var length = Math.min(objKeys.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\n    for (var i = 0; i < length; i++) {\n      var property = objKeys[i];\n      fn(property, isGetter(property));\n    }\n\n    return objKeys.length > length;\n  };\n\n  PrettyPrinter.prototype.emitScalar = function(value) {\n    this.append(value);\n  };\n\n  PrettyPrinter.prototype.emitString = function(value) {\n    this.append('\\'' + value + '\\'');\n  };\n\n  PrettyPrinter.prototype.emitArray = function(array) {\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      this.append('Array');\n      return;\n    }\n    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\n    this.append('[ ');\n    for (var i = 0; i < length; i++) {\n      if (i > 0) {\n        this.append(', ');\n      }\n      this.format(array[i]);\n    }\n    if(array.length > length){\n      this.append(', ...');\n    }\n\n    var self = this;\n    var first = array.length === 0;\n    var truncated = this.iterateObject(array, function(property, isGetter) {\n      if (first) {\n        first = false;\n      } else {\n        self.append(', ');\n      }\n\n      self.formatProperty(array, property, isGetter);\n    });\n\n    if (truncated) { this.append(', ...'); }\n\n    this.append(' ]');\n  };\n\n  PrettyPrinter.prototype.emitSet = function(set) {\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      this.append('Set');\n      return;\n    }\n    this.append('Set( ');\n    var size = Math.min(set.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\n    var i = 0;\n    set.forEach( function( value, key ) {\n      if (i >= size) {\n        return;\n      }\n      if (i > 0) {\n        this.append(', ');\n      }\n      this.format(value);\n\n      i++;\n    }, this );\n    if (set.size > size){\n      this.append(', ...');\n    }\n    this.append(' )');\n  };\n\n  PrettyPrinter.prototype.emitMap = function(map) {\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      this.append('Map');\n      return;\n    }\n    this.append('Map( ');\n    var size = Math.min(map.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\n    var i = 0;\n    map.forEach( function( value, key ) {\n      if (i >= size) {\n        return;\n      }\n      if (i > 0) {\n        this.append(', ');\n      }\n      this.format([key,value]);\n\n      i++;\n    }, this );\n    if (map.size > size){\n      this.append(', ...');\n    }\n    this.append(' )');\n  };\n\n  PrettyPrinter.prototype.emitObject = function(obj) {\n    var ctor = obj.constructor,\n        constructorName;\n\n    constructorName = typeof ctor === 'function' && obj instanceof ctor ?\n      j$.fnNameFor(obj.constructor) :\n      'null';\n\n    this.append(constructorName);\n\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      return;\n    }\n\n    var self = this;\n    this.append('({ ');\n    var first = true;\n\n    var truncated = this.iterateObject(obj, function(property, isGetter) {\n      if (first) {\n        first = false;\n      } else {\n        self.append(', ');\n      }\n\n      self.formatProperty(obj, property, isGetter);\n    });\n\n    if (truncated) { this.append(', ...'); }\n\n    this.append(' })');\n  };\n\n  PrettyPrinter.prototype.emitTypedArray = function(arr) {\n    var constructorName = j$.fnNameFor(arr.constructor),\n      limitedArray = Array.prototype.slice.call(arr, 0, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH),\n      itemsString = Array.prototype.join.call(limitedArray, ', ');\n\n    if (limitedArray.length !== arr.length) {\n      itemsString += ', ...';\n    }\n\n    this.append(constructorName + ' [ ' + itemsString + ' ]');\n  };\n\n  PrettyPrinter.prototype.emitDomElement = function(el) {\n    var closingTag = '</' + el.tagName.toLowerCase() + '>';\n\n    if (el.innerHTML === '') {\n      this.append(el.outerHTML.replace(closingTag, ''));\n    } else {\n      var tagEnd = el.outerHTML.indexOf(el.innerHTML);\n      this.append(el.outerHTML.substring(0, tagEnd));\n      this.append('...' + closingTag);\n    }\n  };\n\n  PrettyPrinter.prototype.formatProperty = function(obj, property, isGetter) {\n      this.append(property);\n      this.append(': ');\n      if (isGetter) {\n        this.append('<getter>');\n      } else {\n        this.format(obj[property]);\n      }\n  };\n\n  PrettyPrinter.prototype.append = function(value) {\n    var result = truncate(value, j$.MAX_PRETTY_PRINT_CHARS - this.length);\n    this.length += result.value.length;\n    this.stringParts.push(result.value);\n\n    if (result.truncated) {\n      throw new MaxCharsReachedError();\n    }\n  };\n\n\n  function truncate(s, maxlen) {\n    if (s.length <= maxlen) {\n      return { value: s, truncated: false };\n    }\n\n    s = s.substring(0, maxlen - 4) + ' ...';\n    return { value: s, truncated: true };\n  }\n\n  function MaxCharsReachedError() {\n    this.message = 'Exceeded ' + j$.MAX_PRETTY_PRINT_CHARS +\n      ' characters while pretty-printing a value';\n  }\n\n  MaxCharsReachedError.prototype = new Error();\n\n  function keys(obj, isArray) {\n    var allKeys = Object.keys ? Object.keys(obj) :\n      (function(o) {\n          var keys = [];\n          for (var key in o) {\n              if (j$.util.has(o, key)) {\n                  keys.push(key);\n              }\n          }\n          return keys;\n      })(obj);\n\n    if (!isArray) {\n      return allKeys;\n    }\n\n    if (allKeys.length === 0) {\n        return allKeys;\n    }\n\n    var extraKeys = [];\n    for (var i = 0; i < allKeys.length; i++) {\n      if (!/^[0-9]+$/.test(allKeys[i])) {\n        extraKeys.push(allKeys[i]);\n      }\n    }\n\n    return extraKeys;\n  }\n  return function(value) {\n    var prettyPrinter = new PrettyPrinter();\n    prettyPrinter.format(value);\n    return prettyPrinter.stringParts.join('');\n  };\n};\n\ngetJasmineRequireObj().QueueRunner = function(j$) {\n  function StopExecutionError() {}\n  StopExecutionError.prototype = new Error();\n  j$.StopExecutionError = StopExecutionError;\n\n  function once(fn) {\n    var called = false;\n    return function() {\n      if (!called) {\n        called = true;\n        fn.apply(null, arguments);\n      }\n      return null;\n    };\n  }\n\n  function QueueRunner(attrs) {\n    var queueableFns = attrs.queueableFns || [];\n    this.queueableFns = queueableFns.concat(attrs.cleanupFns || []);\n    this.firstCleanupIx = queueableFns.length;\n    this.onComplete = attrs.onComplete || function() {};\n    this.clearStack = attrs.clearStack || function(fn) {fn();};\n    this.onException = attrs.onException || function() {};\n    this.userContext = attrs.userContext || new j$.UserContext();\n    this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\n    this.fail = attrs.fail || function() {};\n    this.globalErrors = attrs.globalErrors || { pushListener: function() {}, popListener: function() {} };\n    this.completeOnFirstError = !!attrs.completeOnFirstError;\n    this.errored = false;\n\n    if (typeof(this.onComplete) !== 'function') {\n      throw new Error('invalid onComplete ' + JSON.stringify(this.onComplete));\n    }\n    this.deprecated = attrs.deprecated;\n  }\n\n  QueueRunner.prototype.execute = function() {\n    var self = this;\n    this.handleFinalError = function(error) {\n      self.onException(error);\n    };\n    this.globalErrors.pushListener(this.handleFinalError);\n    this.run(0);\n  };\n\n  QueueRunner.prototype.skipToCleanup = function(lastRanIndex) {\n    if (lastRanIndex < this.firstCleanupIx) {\n      this.run(this.firstCleanupIx);\n    } else {\n      this.run(lastRanIndex + 1);\n    }\n  };\n\n  QueueRunner.prototype.clearTimeout = function(timeoutId) {\n    Function.prototype.apply.apply(this.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]);\n  };\n\n  QueueRunner.prototype.setTimeout = function(fn, timeout) {\n    return Function.prototype.apply.apply(this.timeout.setTimeout, [j$.getGlobal(), [fn, timeout]]);\n  };\n\n  QueueRunner.prototype.attempt = function attempt(iterativeIndex) {\n    var self = this, completedSynchronously = true,\n      handleError = function handleError(error) {\n        onException(error);\n        next(error);\n      },\n      cleanup = once(function cleanup() {\n        self.clearTimeout(timeoutId);\n        self.globalErrors.popListener(handleError);\n      }),\n      next = once(function next(err) {\n        cleanup();\n\n        if (j$.isError_(err)) {\n          if (!(err instanceof StopExecutionError)) {\n            self.fail(err);\n          }\n          self.errored = errored = true;\n        }\n\n        function runNext() {\n          if (self.completeOnFirstError && errored) {\n            self.skipToCleanup(iterativeIndex);\n          } else {\n            self.run(iterativeIndex + 1);\n          }\n        }\n\n        if (completedSynchronously) {\n          self.setTimeout(runNext);\n        } else {\n          runNext();\n        }\n      }),\n      errored = false,\n      queueableFn = self.queueableFns[iterativeIndex],\n      timeoutId;\n\n    next.fail = function nextFail() {\n      self.fail.apply(null, arguments);\n      self.errored = errored = true;\n      next();\n    };\n\n    self.globalErrors.pushListener(handleError);\n\n    if (queueableFn.timeout) {\n      timeoutId = self.setTimeout(function() {\n        var error = new Error('Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.');\n        onException(error);\n        next();\n      }, queueableFn.timeout());\n    }\n\n    try {\n      if (queueableFn.fn.length === 0) {\n        var maybeThenable = queueableFn.fn.call(self.userContext);\n\n        if (maybeThenable && j$.isFunction_(maybeThenable.then)) {\n          maybeThenable.then(next, onPromiseRejection);\n          completedSynchronously = false;\n          return { completedSynchronously: false };\n        }\n      } else {\n        queueableFn.fn.call(self.userContext, next);\n        completedSynchronously = false;\n        return { completedSynchronously: false };\n      }\n    } catch (e) {\n      onException(e);\n      self.errored = errored = true;\n    }\n\n    cleanup();\n    return { completedSynchronously: true, errored: errored };\n\n    function onException(e) {\n      self.onException(e);\n      self.errored = errored = true;\n    }\n\n    function onPromiseRejection(e) {\n      onException(e);\n      next();\n    }\n  };\n\n  QueueRunner.prototype.run = function(recursiveIndex) {\n    var length = this.queueableFns.length,\n      self = this,\n      iterativeIndex;\n\n\n    for(iterativeIndex = recursiveIndex; iterativeIndex < length; iterativeIndex++) {\n      var result = this.attempt(iterativeIndex);\n\n      if (!result.completedSynchronously) {\n        return;\n      }\n\n      self.errored = result.errored;\n\n      if (this.completeOnFirstError && result.errored) {\n        this.skipToCleanup(iterativeIndex);\n        return;\n      }\n    }\n\n    this.clearStack(function() {\n      self.globalErrors.popListener(self.handleFinalError);\n      self.onComplete(self.errored && new StopExecutionError());\n    });\n\n  };\n\n  return QueueRunner;\n};\n\ngetJasmineRequireObj().ReportDispatcher = function(j$) {\n  function ReportDispatcher(methods, queueRunnerFactory) {\n\n    var dispatchedMethods = methods || [];\n\n    for (var i = 0; i < dispatchedMethods.length; i++) {\n      var method = dispatchedMethods[i];\n      this[method] = (function(m) {\n        return function() {\n          dispatch(m, arguments);\n        };\n      }(method));\n    }\n\n    var reporters = [];\n    var fallbackReporter = null;\n\n    this.addReporter = function(reporter) {\n      reporters.push(reporter);\n    };\n\n    this.provideFallbackReporter = function(reporter) {\n      fallbackReporter = reporter;\n    };\n\n    this.clearReporters = function() {\n      reporters = [];\n    };\n\n    return this;\n\n    function dispatch(method, args) {\n      if (reporters.length === 0 && fallbackReporter !== null) {\n          reporters.push(fallbackReporter);\n      }\n      var onComplete = args[args.length - 1];\n      args = j$.util.argsToArray(args).splice(0, args.length - 1);\n      var fns = [];\n      for (var i = 0; i < reporters.length; i++) {\n        var reporter = reporters[i];\n        addFn(fns, reporter, method, args);\n      }\n\n      queueRunnerFactory({\n        queueableFns: fns,\n        onComplete: onComplete,\n        isReporter: true\n      });\n    }\n\n    function addFn(fns, reporter, method, args) {\n      var fn = reporter[method];\n      if (!fn) {\n        return;\n      }\n\n      var thisArgs = j$.util.cloneArgs(args);\n      if (fn.length <= 1) {\n        fns.push({\n          fn: function () {\n            return fn.apply(reporter, thisArgs);\n          }\n        });\n      } else {\n        fns.push({\n          fn: function (done) {\n            return fn.apply(reporter, thisArgs.concat([done]));\n          }\n        });\n      }\n    }\n  }\n\n  return ReportDispatcher;\n};\n\n\ngetJasmineRequireObj().interface = function(jasmine, env) {\n  var jasmineInterface = {\n    /**\n     * Callback passed to parts of the Jasmine base interface.\n     *\n     * By default Jasmine assumes this function completes synchronously.\n     * If you have code that you need to test asynchronously, you can declare that you receive a `done` callback, return a Promise, or use the `async` keyword if it is supported in your environment.\n     * @callback implementationCallback\n     * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.\n     * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.\n     */\n\n    /**\n     * Create a group of specs (often called a suite).\n     *\n     * Calls to `describe` can be nested within other calls to compose your suite as a tree.\n     * @name describe\n     * @function\n     * @global\n     * @param {String} description Textual description of the group\n     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs\n     */\n    describe: function(description, specDefinitions) {\n      return env.describe(description, specDefinitions);\n    },\n\n    /**\n     * A temporarily disabled [`describe`]{@link describe}\n     *\n     * Specs within an `xdescribe` will be marked pending and not executed\n     * @name xdescribe\n     * @function\n     * @global\n     * @param {String} description Textual description of the group\n     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs\n     */\n    xdescribe: function(description, specDefinitions) {\n      return env.xdescribe(description, specDefinitions);\n    },\n\n    /**\n     * A focused [`describe`]{@link describe}\n     *\n     * If suites or specs are focused, only those that are focused will be executed\n     * @see fit\n     * @name fdescribe\n     * @function\n     * @global\n     * @param {String} description Textual description of the group\n     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs\n     */\n    fdescribe: function(description, specDefinitions) {\n      return env.fdescribe(description, specDefinitions);\n    },\n\n    /**\n     * Define a single spec. A spec should contain one or more {@link expect|expectations} that test the state of the code.\n     *\n     * A spec whose expectations all succeed will be passing and a spec with any failures will fail.\n     * @name it\n     * @function\n     * @global\n     * @param {String} description Textual description of what this spec is checking\n     * @param {implementationCallback} [testFunction] Function that contains the code of your test. If not provided the test will be `pending`.\n     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.\n     */\n    it: function() {\n      return env.it.apply(env, arguments);\n    },\n\n    /**\n     * A temporarily disabled [`it`]{@link it}\n     *\n     * The spec will report as `pending` and will not be executed.\n     * @name xit\n     * @function\n     * @global\n     * @param {String} description Textual description of what this spec is checking.\n     * @param {implementationCallback} [testFunction] Function that contains the code of your test. Will not be executed.\n     */\n    xit: function() {\n      return env.xit.apply(env, arguments);\n    },\n\n    /**\n     * A focused [`it`]{@link it}\n     *\n     * If suites or specs are focused, only those that are focused will be executed.\n     * @name fit\n     * @function\n     * @global\n     * @param {String} description Textual description of what this spec is checking.\n     * @param {implementationCallback} testFunction Function that contains the code of your test.\n     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.\n     */\n    fit: function() {\n      return env.fit.apply(env, arguments);\n    },\n\n    /**\n     * Run some shared setup before each of the specs in the {@link describe} in which it is called.\n     * @name beforeEach\n     * @function\n     * @global\n     * @param {implementationCallback} [function] Function that contains the code to setup your specs.\n     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeEach.\n     */\n    beforeEach: function() {\n      return env.beforeEach.apply(env, arguments);\n    },\n\n    /**\n     * Run some shared teardown after each of the specs in the {@link describe} in which it is called.\n     * @name afterEach\n     * @function\n     * @global\n     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.\n     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterEach.\n     */\n    afterEach: function() {\n      return env.afterEach.apply(env, arguments);\n    },\n\n    /**\n     * Run some shared setup once before all of the specs in the {@link describe} are run.\n     *\n     * _Note:_ Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.\n     * @name beforeAll\n     * @function\n     * @global\n     * @param {implementationCallback} [function] Function that contains the code to setup your specs.\n     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeAll.\n     */\n    beforeAll: function() {\n      return env.beforeAll.apply(env, arguments);\n    },\n\n    /**\n     * Run some shared teardown once after all of the specs in the {@link describe} are run.\n     *\n     * _Note:_ Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.\n     * @name afterAll\n     * @function\n     * @global\n     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.\n     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterAll.\n     */\n    afterAll: function() {\n      return env.afterAll.apply(env, arguments);\n    },\n\n    /**\n     * Create an expectation for a spec.\n     * @name expect\n     * @function\n     * @global\n     * @param {Object} actual - Actual computed value to test expectations against.\n     * @return {matchers}\n     */\n    expect: function(actual) {\n      return env.expect(actual);\n    },\n\n    /**\n     * Mark a spec as pending, expectation results will be ignored.\n     * @name pending\n     * @function\n     * @global\n     * @param {String} [message] - Reason the spec is pending.\n     */\n    pending: function() {\n      return env.pending.apply(env, arguments);\n    },\n\n    /**\n     * Explicitly mark a spec as failed.\n     * @name fail\n     * @function\n     * @global\n     * @param {String|Error} [error] - Reason for the failure.\n    */\n    fail: function() {\n      return env.fail.apply(env, arguments);\n    },\n\n    /**\n     * Install a spy onto an existing object.\n     * @name spyOn\n     * @function\n     * @global\n     * @param {Object} obj - The object upon which to install the {@link Spy}.\n     * @param {String} methodName - The name of the method to replace with a {@link Spy}.\n     * @returns {Spy}\n     */\n    spyOn: function(obj, methodName) {\n      return env.spyOn(obj, methodName);\n    },\n\n    /**\n     * Install a spy on a property installed with `Object.defineProperty` onto an existing object.\n     * @name spyOnProperty\n     * @function\n     * @global\n     * @param {Object} obj - The object upon which to install the {@link Spy}\n     * @param {String} propertyName - The name of the property to replace with a {@link Spy}.\n     * @param {String} [accessType=get] - The access type (get|set) of the property to {@link Spy} on.\n     * @returns {Spy}\n     */\n    spyOnProperty: function(obj, methodName, accessType) {\n      return env.spyOnProperty(obj, methodName, accessType);\n    },\n\n    jsApiReporter: new jasmine.JsApiReporter({\n      timer: new jasmine.Timer()\n    }),\n\n    /**\n     * @namespace jasmine\n     */\n    jasmine: jasmine\n  };\n\n  /**\n   * Add a custom equality tester for the current scope of specs.\n   *\n   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.\n   * @name jasmine.addCustomEqualityTester\n   * @function\n   * @param {Function} tester - A function which takes two arguments to compare and returns a `true` or `false` comparison result if it knows how to compare them, and `undefined` otherwise.\n   * @see custom_equality\n   */\n  jasmine.addCustomEqualityTester = function(tester) {\n    env.addCustomEqualityTester(tester);\n  };\n\n  /**\n   * Add custom matchers for the current scope of specs.\n   *\n   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.\n   * @name jasmine.addMatchers\n   * @function\n   * @param {Object} matchers - Keys from this object will be the new matcher names.\n   * @see custom_matcher\n   */\n  jasmine.addMatchers = function(matchers) {\n    return env.addMatchers(matchers);\n  };\n\n  /**\n   * Get the currently booted mock {Clock} for this Jasmine environment.\n   * @name jasmine.clock\n   * @function\n   * @returns {Clock}\n   */\n  jasmine.clock = function() {\n    return env.clock;\n  };\n\n  /**\n   * Create a bare {@link Spy} object. This won't be installed anywhere and will not have any implementation behind it.\n   * @name jasmine.createSpy\n   * @function\n   * @param {String} [name] - Name to give the spy. This will be displayed in failure messages.\n   * @param {Function} [originalFn] - Function to act as the real implementation.\n   * @return {Spy}\n   */\n  jasmine.createSpy = function(name, originalFn) {\n    return env.createSpy(name, originalFn);\n  };\n\n  /**\n   * Create an object with multiple {@link Spy}s as its members.\n   * @name jasmine.createSpyObj\n   * @function\n   * @param {String} [baseName] - Base name for the spies in the object.\n   * @param {String[]|Object} methodNames - Array of method names to create spies for, or Object whose keys will be method names and values the {@link Spy#and#returnValue|returnValue}.\n   * @return {Object}\n   */\n  jasmine.createSpyObj = function(baseName, methodNames) {\n    return env.createSpyObj(baseName, methodNames);\n  };\n\n  /**\n   * Add a custom spy strategy for the current scope of specs.\n   *\n   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.\n   * @name jasmine.addSpyStrategy\n   * @function\n   * @param {String} name - The name of the strategy (i.e. what you call from `and`)\n   * @param {Function} factory - Factory function that returns the plan to be executed.\n   */\n  jasmine.addSpyStrategy = function(name, factory) {\n    return env.addSpyStrategy(name, factory);\n  };\n\n  return jasmineInterface;\n};\n\ngetJasmineRequireObj().Spy = function (j$) {\n\n  var nextOrder = (function() {\n    var order = 0;\n\n    return function() {\n      return order++;\n    };\n  })();\n\n  /**\n   * _Note:_ Do not construct this directly, use {@link spyOn}, {@link spyOnProperty}, {@link jasmine.createSpy}, or {@link jasmine.createSpyObj}\n   * @constructor\n   * @name Spy\n   */\n  function Spy(name, originalFn, customStrategies) {\n    var numArgs = (typeof originalFn === 'function' ? originalFn.length : 0),\n      wrapper = makeFunc(numArgs, function () {\n        return spy.apply(this, Array.prototype.slice.call(arguments));\n      }),\n      strategyDispatcher = new SpyStrategyDispatcher({\n        name: name,\n        fn: originalFn,\n        getSpy: function () {\n          return wrapper;\n        },\n        customStrategies: customStrategies\n      }),\n      callTracker = new j$.CallTracker(),\n      spy = function () {\n        /**\n         * @name Spy.callData\n         * @property {object} object - `this` context for the invocation.\n         * @property {number} invocationOrder - Order of the invocation.\n         * @property {Array} args - The arguments passed for this invocation.\n         */\n        var callData = {\n          object: this,\n          invocationOrder: nextOrder(),\n          args: Array.prototype.slice.apply(arguments)\n        };\n\n        callTracker.track(callData);\n        var returnValue = strategyDispatcher.exec(this, arguments);\n        callData.returnValue = returnValue;\n\n        return returnValue;\n      };\n\n    function makeFunc(length, fn) {\n      switch (length) {\n        case 1 : return function (a) { return fn.apply(this, arguments); };\n        case 2 : return function (a,b) { return fn.apply(this, arguments); };\n        case 3 : return function (a,b,c) { return fn.apply(this, arguments); };\n        case 4 : return function (a,b,c,d) { return fn.apply(this, arguments); };\n        case 5 : return function (a,b,c,d,e) { return fn.apply(this, arguments); };\n        case 6 : return function (a,b,c,d,e,f) { return fn.apply(this, arguments); };\n        case 7 : return function (a,b,c,d,e,f,g) { return fn.apply(this, arguments); };\n        case 8 : return function (a,b,c,d,e,f,g,h) { return fn.apply(this, arguments); };\n        case 9 : return function (a,b,c,d,e,f,g,h,i) { return fn.apply(this, arguments); };\n        default : return function () { return fn.apply(this, arguments); };\n      }\n    }\n\n    for (var prop in originalFn) {\n      if (prop === 'and' || prop === 'calls') {\n        throw new Error('Jasmine spies would overwrite the \\'and\\' and \\'calls\\' properties on the object being spied upon');\n      }\n\n      wrapper[prop] = originalFn[prop];\n    }\n\n    /**\n     * @member {SpyStrategy} - Accesses the default strategy for the spy. This strategy will be used\n     * whenever the spy is called with arguments that don't match any strategy\n     * created with {@link Spy#withArgs}.\n     * @name Spy#and\n     * @example\n     * spyOn(someObj, 'func').and.returnValue(42);\n     */\n    wrapper.and = strategyDispatcher.and;\n    /**\n     * Specifies a strategy to be used for calls to the spy that have the\n     * specified arguments.\n     * @name Spy#withArgs\n     * @function\n     * @param {...*} args - The arguments to match\n     * @type {SpyStrategy}\n     * @example\n     * spyOn(someObj, 'func').withArgs(1, 2, 3).and.returnValue(42);\n     * someObj.func(1, 2, 3); // returns 42\n     */\n    wrapper.withArgs = function() {\n      return strategyDispatcher.withArgs.apply(strategyDispatcher, arguments);\n    };\n    wrapper.calls = callTracker;\n\n    return wrapper;\n  }\n\n\n  function SpyStrategyDispatcher(strategyArgs) {\n    var baseStrategy = new j$.SpyStrategy(strategyArgs);\n    var argsStrategies = new StrategyDict(function() {\n      return new j$.SpyStrategy(strategyArgs);\n    });\n\n    this.and = baseStrategy;\n\n    this.exec = function(spy, args) {\n      var strategy = argsStrategies.get(args);\n\n      if (!strategy) {\n        if (argsStrategies.any() && !baseStrategy.isConfigured()) {\n          throw new Error('Spy \\'' + strategyArgs.name + '\\' receieved a call with arguments ' + j$.pp(Array.prototype.slice.call(args)) + ' but all configured strategies specify other arguments.');\n        } else {\n          strategy = baseStrategy;\n        }\n      }\n\n      return strategy.exec(spy, args);\n    };\n\n    this.withArgs = function() {\n      return { and: argsStrategies.getOrCreate(arguments) };\n    };\n  }\n\n  function StrategyDict(strategyFactory) {\n    this.strategies = [];\n    this.strategyFactory = strategyFactory;\n  }\n\n  StrategyDict.prototype.any = function() {\n    return this.strategies.length > 0;\n  };\n\n  StrategyDict.prototype.getOrCreate = function(args) {\n    var strategy = this.get(args);\n\n    if (!strategy) {\n      strategy = this.strategyFactory();\n      this.strategies.push({\n        args: args,\n        strategy: strategy\n      });\n    }\n\n    return strategy;\n  };\n\n  StrategyDict.prototype.get = function(args) {\n    var i;\n\n    for (i = 0; i < this.strategies.length; i++) {\n      if (j$.matchersUtil.equals(args, this.strategies[i].args)) {\n        return this.strategies[i].strategy;\n      }\n    }\n  };\n\n  return Spy;\n};\n\ngetJasmineRequireObj().SpyFactory = function(j$) {\n\n  function SpyFactory(getCustomStrategies) {\n    var self = this;\n\n    this.createSpy = function(name, originalFn) {\n      return j$.Spy(name, originalFn, getCustomStrategies());\n    };\n\n    this.createSpyObj = function(baseName, methodNames) {\n      var baseNameIsCollection = j$.isObject_(baseName) || j$.isArray_(baseName);\n\n      if (baseNameIsCollection && j$.util.isUndefined(methodNames)) {\n        methodNames = baseName;\n        baseName = 'unknown';\n      }\n\n      var obj = {};\n      var spiesWereSet = false;\n\n      if (j$.isArray_(methodNames)) {\n        for (var i = 0; i < methodNames.length; i++) {\n          obj[methodNames[i]] = self.createSpy(baseName + '.' + methodNames[i]);\n          spiesWereSet = true;\n        }\n      } else if (j$.isObject_(methodNames)) {\n        for (var key in methodNames) {\n          if (methodNames.hasOwnProperty(key)) {\n            obj[key] = self.createSpy(baseName + '.' + key);\n            obj[key].and.returnValue(methodNames[key]);\n            spiesWereSet = true;\n          }\n        }\n      }\n\n      if (!spiesWereSet) {\n        throw 'createSpyObj requires a non-empty array or object of method names to create spies for';\n      }\n\n      return obj;\n    };\n  }\n\n  return SpyFactory;\n};\n\ngetJasmineRequireObj().SpyRegistry = function(j$) {\n\n  var getErrorMsg = j$.formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');\n\n  function SpyRegistry(options) {\n    options = options || {};\n    var global = options.global || j$.getGlobal();\n    var createSpy = options.createSpy;\n    var currentSpies = options.currentSpies || function() { return []; };\n\n    this.allowRespy = function(allow){\n      this.respy = allow;\n    };\n\n    this.spyOn = function(obj, methodName) {\n\n      if (j$.util.isUndefined(obj) || obj === null) {\n        throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));\n      }\n\n      if (j$.util.isUndefined(methodName) || methodName === null) {\n        throw new Error(getErrorMsg('No method name supplied'));\n      }\n\n      if (j$.util.isUndefined(obj[methodName])) {\n        throw new Error(getErrorMsg(methodName + '() method does not exist'));\n      }\n\n      if (obj[methodName] && j$.isSpy(obj[methodName])  ) {\n        if ( !!this.respy ){\n          return obj[methodName];\n        }else {\n          throw new Error(getErrorMsg(methodName + ' has already been spied upon'));\n        }\n      }\n\n      var descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\n\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\n        throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));\n      }\n\n      var originalMethod = obj[methodName],\n        spiedMethod = createSpy(methodName, originalMethod),\n        restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, methodName) || (obj === global && methodName === 'onerror')) {\n        restoreStrategy = function() {\n          obj[methodName] = originalMethod;\n        };\n      } else {\n        restoreStrategy = function() {\n          if (!delete obj[methodName]) {\n            obj[methodName] = originalMethod;\n          }\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n\n      obj[methodName] = spiedMethod;\n\n      return spiedMethod;\n    };\n\n    this.spyOnProperty = function (obj, propertyName, accessType) {\n      accessType = accessType || 'get';\n\n      if (j$.util.isUndefined(obj)) {\n        throw new Error('spyOn could not find an object to spy upon for ' + propertyName + '');\n      }\n\n      if (j$.util.isUndefined(propertyName)) {\n        throw new Error('No property name supplied');\n      }\n\n      var descriptor = j$.util.getPropertyDescriptor(obj, propertyName);\n\n      if (!descriptor) {\n        throw new Error(propertyName + ' property does not exist');\n      }\n\n      if (!descriptor.configurable) {\n        throw new Error(propertyName + ' is not declared configurable');\n      }\n\n      if(!descriptor[accessType]) {\n        throw new Error('Property ' + propertyName + ' does not have access type ' + accessType);\n      }\n\n      if (j$.isSpy(descriptor[accessType])) {\n        //TODO?: should this return the current spy? Downside: may cause user confusion about spy state\n        throw new Error(propertyName + ' has already been spied upon');\n      }\n\n      var originalDescriptor = j$.util.clone(descriptor),\n        spy = createSpy(propertyName, descriptor[accessType]),\n        restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {\n        restoreStrategy = function() {\n          Object.defineProperty(obj, propertyName, originalDescriptor);\n        };\n      } else {\n        restoreStrategy = function() {\n          delete obj[propertyName];\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n\n      descriptor[accessType] = spy;\n\n      Object.defineProperty(obj, propertyName, descriptor);\n\n      return spy;\n    };\n\n    this.clearSpies = function() {\n      var spies = currentSpies();\n      for (var i = spies.length - 1; i >= 0; i--) {\n        var spyEntry = spies[i];\n        spyEntry.restoreObjectToOriginalState();\n      }\n    };\n  }\n\n  return SpyRegistry;\n};\n\ngetJasmineRequireObj().SpyStrategy = function(j$) {\n\n  /**\n   * @interface SpyStrategy\n   */\n  function SpyStrategy(options) {\n    options = options || {};\n\n    /**\n     * Get the identifying information for the spy.\n     * @name SpyStrategy#identity\n     * @member\n     * @type {String}\n     */\n    this.identity = options.name || 'unknown';\n    this.originalFn = options.fn || function() {};\n    this.getSpy = options.getSpy || function() {};\n    this.plan = this._defaultPlan = function() {};\n\n    var k, cs = options.customStrategies || {};\n    for (k in cs) {\n      if (j$.util.has(cs, k) && !this[k]) {\n        this[k] = createCustomPlan(cs[k]);\n      }\n    }\n  }\n\n  function createCustomPlan(factory) {\n    return function() {\n      var plan = factory.apply(null, arguments);\n\n      if (!j$.isFunction_(plan)) {\n        throw new Error('Spy strategy must return a function');\n      }\n\n      this.plan = plan;\n      return this.getSpy();\n    };\n  }\n\n  /**\n   * Execute the current spy strategy.\n   * @name SpyStrategy#exec\n   * @function\n   */\n  SpyStrategy.prototype.exec = function(context, args) {\n    return this.plan.apply(context, args);\n  };\n\n  /**\n   * Tell the spy to call through to the real implementation when invoked.\n   * @name SpyStrategy#callThrough\n   * @function\n   */\n  SpyStrategy.prototype.callThrough = function() {\n    this.plan = this.originalFn;\n    return this.getSpy();\n  };\n\n  /**\n   * Tell the spy to return the value when invoked.\n   * @name SpyStrategy#returnValue\n   * @function\n   * @param {*} value The value to return.\n   */\n  SpyStrategy.prototype.returnValue = function(value) {\n    this.plan = function() {\n      return value;\n    };\n    return this.getSpy();\n  };\n\n  /**\n   * Tell the spy to return one of the specified values (sequentially) each time the spy is invoked.\n   * @name SpyStrategy#returnValues\n   * @function\n   * @param {...*} values - Values to be returned on subsequent calls to the spy.\n   */\n  SpyStrategy.prototype.returnValues = function() {\n    var values = Array.prototype.slice.call(arguments);\n    this.plan = function () {\n      return values.shift();\n    };\n    return this.getSpy();\n  };\n\n  /**\n   * Tell the spy to throw an error when invoked.\n   * @name SpyStrategy#throwError\n   * @function\n   * @param {Error|String} something Thing to throw\n   */\n  SpyStrategy.prototype.throwError = function(something) {\n    var error = (something instanceof Error) ? something : new Error(something);\n    this.plan = function() {\n      throw error;\n    };\n    return this.getSpy();\n  };\n\n  /**\n   * Tell the spy to call a fake implementation when invoked.\n   * @name SpyStrategy#callFake\n   * @function\n   * @param {Function} fn The function to invoke with the passed parameters.\n   */\n  SpyStrategy.prototype.callFake = function(fn) {\n    if(!(j$.isFunction_(fn) || j$.isAsyncFunction_(fn))) {\n      throw new Error('Argument passed to callFake should be a function, got ' + fn);\n    }\n    this.plan = fn;\n    return this.getSpy();\n  };\n\n  /**\n   * Tell the spy to do nothing when invoked. This is the default.\n   * @name SpyStrategy#stub\n   * @function\n   */\n  SpyStrategy.prototype.stub = function(fn) {\n    this.plan = function() {};\n    return this.getSpy();\n  };\n\n  SpyStrategy.prototype.isConfigured = function() {\n    return this.plan !== this._defaultPlan;\n  };\n\n  return SpyStrategy;\n};\n\ngetJasmineRequireObj().StackTrace = function(j$) {\n  function StackTrace(rawTrace) {\n    var lines = rawTrace\n      .split('\\n')\n      .filter(function(line) { return line !== ''; });\n\n    if (lines[0].match(/^Error/)) {\n      this.message = lines.shift();\n    } else {\n      this.message = undefined;\n    }\n\n    var parseResult = tryParseFrames(lines);\n    this.frames = parseResult.frames;\n    this.style = parseResult.style;\n  }\n\n  var framePatterns = [\n    // PhantomJS on Linux, Node, Chrome, IE, Edge\n    // e.g. \"   at QueueRunner.run (http://localhost:8888/__jasmine__/jasmine.js:4320:20)\"\n    // Note that the \"function name\" can include a surprisingly large set of\n    // characters, including angle brackets and square brackets.\n    { re: /^\\s*at ([^\\)]+) \\(([^\\)]+)\\)$/, fnIx: 1, fileLineColIx: 2, style: 'v8' },\n\n    // NodeJS alternate form, often mixed in with the Chrome style\n    // e.g. \"  at /some/path:4320:20\n    { re: /\\s*at (.+)$/, fileLineColIx: 1, style: 'v8' },\n\n    // PhantomJS on OS X, Safari, Firefox\n    // e.g. \"run@http://localhost:8888/__jasmine__/jasmine.js:4320:27\"\n    // or \"http://localhost:8888/__jasmine__/jasmine.js:4320:27\"\n    { re: /^(([^@\\s]+)@)?([^\\s]+)$/, fnIx: 2, fileLineColIx: 3, style: 'webkit' }\n  ];\n\n  // regexes should capture the function name (if any) as group 1\n  // and the file, line, and column as group 2.\n  function tryParseFrames(lines) {\n    var style = null;\n    var frames = lines.map(function(line) {\n      var convertedLine = first(framePatterns, function(pattern) {\n        var overallMatch = line.match(pattern.re),\n          fileLineColMatch;\n        if (!overallMatch) { return null; }\n\n        fileLineColMatch = overallMatch[pattern.fileLineColIx].match(\n          /^(.*):(\\d+):\\d+$/);\n        if (!fileLineColMatch) { return null; }\n\n        style = style || pattern.style;\n        return {\n          raw: line,\n          file: fileLineColMatch[1],\n          line: parseInt(fileLineColMatch[2], 10),\n          func: overallMatch[pattern.fnIx]\n        };\n      });\n\n      return convertedLine || { raw: line };\n    });\n\n    return {\n      style: style,\n      frames: frames\n    };\n  }\n\n  function first(items, fn) {\n    var i, result;\n\n    for (i = 0; i < items.length; i++) {\n      result = fn(items[i]);\n\n      if (result) {\n        return result;\n      }\n    }\n  }\n  \n  return StackTrace;\n};\n\ngetJasmineRequireObj().Suite = function(j$) {\n  function Suite(attrs) {\n    this.env = attrs.env;\n    this.id = attrs.id;\n    this.parentSuite = attrs.parentSuite;\n    this.description = attrs.description;\n    this.expectationFactory = attrs.expectationFactory;\n    this.expectationResultFactory = attrs.expectationResultFactory;\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    this.beforeFns = [];\n    this.afterFns = [];\n    this.beforeAllFns = [];\n    this.afterAllFns = [];\n\n    this.children = [];\n\n    /**\n     * @typedef SuiteResult\n     * @property {Int} id - The unique id of this suite.\n     * @property {String} description - The description text passed to the {@link describe} that made this suite.\n     * @property {String} fullName - The full description including all ancestors of this suite.\n     * @property {Expectation[]} failedExpectations - The list of expectations that failed in an {@link afterAll} for this suite.\n     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred on this suite.\n     * @property {String} status - Once the suite has completed, this string represents the pass/fail status of this suite.\n     */\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      deprecationWarnings: []\n    };\n  }\n\n  Suite.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Suite.prototype.getFullName = function() {\n    var fullName = [];\n    for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {\n      if (parentSuite.parentSuite) {\n        fullName.unshift(parentSuite.description);\n      }\n    }\n    return fullName.join(' ');\n  };\n\n  Suite.prototype.pend = function() {\n    this.markedPending = true;\n  };\n\n  Suite.prototype.beforeEach = function(fn) {\n    this.beforeFns.unshift(fn);\n  };\n\n  Suite.prototype.beforeAll = function(fn) {\n    this.beforeAllFns.push(fn);\n  };\n\n  Suite.prototype.afterEach = function(fn) {\n    this.afterFns.unshift(fn);\n  };\n\n  Suite.prototype.afterAll = function(fn) {\n    this.afterAllFns.unshift(fn);\n  };\n\n  function removeFns(queueableFns) {\n    for(var i = 0; i < queueableFns.length; i++) {\n      queueableFns[i].fn = null;\n    }\n  }\n\n  Suite.prototype.cleanupBeforeAfter = function() {\n    removeFns(this.beforeAllFns);\n    removeFns(this.afterAllFns);\n    removeFns(this.beforeFns);\n    removeFns(this.afterFns);\n  };\n\n  Suite.prototype.addChild = function(child) {\n    this.children.push(child);\n  };\n\n  Suite.prototype.status = function() {\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'passed';\n    }\n  };\n\n  Suite.prototype.canBeReentered = function() {\n    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\n  };\n\n  Suite.prototype.getResult = function() {\n    this.result.status = this.status();\n    return this.result;\n  };\n\n  Suite.prototype.sharedUserContext = function() {\n    if (!this.sharedContext) {\n      this.sharedContext = this.parentSuite ? this.parentSuite.clonedSharedUserContext() : new j$.UserContext();\n    }\n\n    return this.sharedContext;\n  };\n\n  Suite.prototype.clonedSharedUserContext = function() {\n    return j$.UserContext.fromExisting(this.sharedUserContext());\n  };\n\n  Suite.prototype.onException = function() {\n    if (arguments[0] instanceof j$.errors.ExpectationFailed) {\n      return;\n    }\n\n    var data = {\n      matcherName: '',\n      passed: false,\n      expected: '',\n      actual: '',\n      error: arguments[0]\n    };\n    var failedExpectation = this.expectationResultFactory(data);\n\n    if (!this.parentSuite) {\n      failedExpectation.globalErrorType = 'afterAll';\n    }\n\n    this.result.failedExpectations.push(failedExpectation);\n  };\n\n  Suite.prototype.addExpectationResult = function () {\n    if(isFailure(arguments)) {\n      var data = arguments[1];\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\n      if(this.throwOnExpectationFailure) {\n        throw new j$.errors.ExpectationFailed();\n      }\n    }\n  };\n\n  Suite.prototype.addDeprecationWarning = function(deprecation) {\n    if (typeof deprecation === 'string') {\n      deprecation = { message: deprecation };\n    }\n    this.result.deprecationWarnings.push(this.expectationResultFactory(deprecation));\n  };\n\n  function isFailure(args) {\n    return !args[0];\n  }\n\n  return Suite;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Suite = jasmineRequire.Suite;\n}\n\ngetJasmineRequireObj().Timer = function() {\n  var defaultNow = (function(Date) {\n    return function() { return new Date().getTime(); };\n  })(Date);\n\n  function Timer(options) {\n    options = options || {};\n\n    var now = options.now || defaultNow,\n      startTime;\n\n    this.start = function() {\n      startTime = now();\n    };\n\n    this.elapsed = function() {\n      return now() - startTime;\n    };\n  }\n\n  return Timer;\n};\n\ngetJasmineRequireObj().TreeProcessor = function() {\n  function TreeProcessor(attrs) {\n    var tree = attrs.tree,\n        runnableIds = attrs.runnableIds,\n        queueRunnerFactory = attrs.queueRunnerFactory,\n        nodeStart = attrs.nodeStart || function() {},\n        nodeComplete = attrs.nodeComplete || function() {},\n        orderChildren = attrs.orderChildren || function(node) { return node.children; },\n        excludeNode = attrs.excludeNode || function(node) { return false; },\n        stats = { valid: true },\n        processed = false,\n        defaultMin = Infinity,\n        defaultMax = 1 - Infinity;\n\n    this.processTree = function() {\n      processNode(tree, true);\n      processed = true;\n      return stats;\n    };\n\n    this.execute = function(done) {\n      if (!processed) {\n        this.processTree();\n      }\n\n      if (!stats.valid) {\n        throw 'invalid order';\n      }\n\n      var childFns = wrapChildren(tree, 0);\n\n      queueRunnerFactory({\n        queueableFns: childFns,\n        userContext: tree.sharedUserContext(),\n        onException: function() {\n          tree.onException.apply(tree, arguments);\n        },\n        onComplete: done\n      });\n    };\n\n    function runnableIndex(id) {\n      for (var i = 0; i < runnableIds.length; i++) {\n        if (runnableIds[i] === id) {\n          return i;\n        }\n      }\n    }\n\n    function processNode(node, parentExcluded) {\n      var executableIndex = runnableIndex(node.id);\n\n      if (executableIndex !== undefined) {\n        parentExcluded = false;\n      }\n\n      if (!node.children) {\n        var excluded = parentExcluded || excludeNode(node);\n        stats[node.id] = {\n          excluded: excluded,\n          willExecute: !excluded && !node.markedPending,\n          segments: [{\n            index: 0,\n            owner: node,\n            nodes: [node],\n            min: startingMin(executableIndex),\n            max: startingMax(executableIndex)\n          }]\n        };\n      } else {\n        var hasExecutableChild = false;\n\n        var orderedChildren = orderChildren(node);\n\n        for (var i = 0; i < orderedChildren.length; i++) {\n          var child = orderedChildren[i];\n\n          processNode(child, parentExcluded);\n\n          if (!stats.valid) {\n            return;\n          }\n\n          var childStats = stats[child.id];\n\n          hasExecutableChild = hasExecutableChild || childStats.willExecute;\n        }\n\n        stats[node.id] = {\n          excluded: parentExcluded,\n          willExecute: hasExecutableChild\n        };\n\n        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);\n\n        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {\n          stats = { valid: false };\n        }\n      }\n    }\n\n    function startingMin(executableIndex) {\n      return executableIndex === undefined ? defaultMin : executableIndex;\n    }\n\n    function startingMax(executableIndex) {\n      return executableIndex === undefined ? defaultMax : executableIndex;\n    }\n\n    function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {\n      var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },\n          result = [currentSegment],\n          lastMax = defaultMax,\n          orderedChildSegments = orderChildSegments(orderedChildren);\n\n      function isSegmentBoundary(minIndex) {\n        return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;\n      }\n\n      for (var i = 0; i < orderedChildSegments.length; i++) {\n        var childSegment = orderedChildSegments[i],\n          maxIndex = childSegment.max,\n          minIndex = childSegment.min;\n\n        if (isSegmentBoundary(minIndex)) {\n          currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};\n          result.push(currentSegment);\n        }\n\n        currentSegment.nodes.push(childSegment);\n        currentSegment.min = Math.min(currentSegment.min, minIndex);\n        currentSegment.max = Math.max(currentSegment.max, maxIndex);\n        lastMax = maxIndex;\n      }\n\n      nodeStats.segments = result;\n    }\n\n    function orderChildSegments(children) {\n      var specifiedOrder = [],\n          unspecifiedOrder = [];\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i],\n            segments = stats[child.id].segments;\n\n        for (var j = 0; j < segments.length; j++) {\n          var seg = segments[j];\n\n          if (seg.min === defaultMin) {\n            unspecifiedOrder.push(seg);\n          } else {\n            specifiedOrder.push(seg);\n          }\n        }\n      }\n\n      specifiedOrder.sort(function(a, b) {\n        return a.min - b.min;\n      });\n\n      return specifiedOrder.concat(unspecifiedOrder);\n    }\n\n    function executeNode(node, segmentNumber) {\n      if (node.children) {\n        return {\n          fn: function(done) {\n            var onStart = {\n              fn: function(next) {\n                nodeStart(node, next);\n              }\n            };\n\n            queueRunnerFactory({\n              onComplete: function () {\n                node.cleanupBeforeAfter();\n                nodeComplete(node, node.getResult(), done);\n              },\n              queueableFns: [onStart].concat(wrapChildren(node, segmentNumber)),\n              userContext: node.sharedUserContext(),\n              onException: function () {\n                node.onException.apply(node, arguments);\n              }\n            });\n          }\n        };\n      } else {\n        return {\n          fn: function(done) { node.execute(done, stats[node.id].excluded); }\n        };\n      }\n    }\n\n    function wrapChildren(node, segmentNumber) {\n      var result = [],\n          segmentChildren = stats[node.id].segments[segmentNumber].nodes;\n\n      for (var i = 0; i < segmentChildren.length; i++) {\n        result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));\n      }\n\n      if (!stats[node.id].willExecute) {\n        return result;\n      }\n\n      return node.beforeAllFns.concat(result).concat(node.afterAllFns);\n    }\n  }\n\n  return TreeProcessor;\n};\n\ngetJasmineRequireObj().UserContext = function(j$) {\n  function UserContext() {\n  }\n\n  UserContext.fromExisting = function(oldContext) {\n    var context = new UserContext();\n\n    for (var prop in oldContext) {\n      if (oldContext.hasOwnProperty(prop)) {\n        context[prop] = oldContext[prop];\n      }\n    }\n\n    return context;\n  };\n\n  return  UserContext;\n};\n\ngetJasmineRequireObj().version = function() {\n  return '3.1.0';\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/jasmine-core/lib/jasmine-core/jasmine.js?");

/***/ }),

/***/ "./node_modules/jasmine-core/lib/jasmine-core/node_boot.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jasmine-core/lib/jasmine-core/node_boot.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/*\nCopyright (c) 2008-2018 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nmodule.exports = function(jasmineRequire) {\n  var jasmine = jasmineRequire.core(jasmineRequire);\n\n  var env = jasmine.getEnv({suppressLoadErrors: true});\n\n  var jasmineInterface = jasmineRequire.interface(jasmine, env);\n\n  extend(global, jasmineInterface);\n\n  function extend(destination, source) {\n    for (var property in source) destination[property] = source[property];\n    return destination;\n  }\n\n  return jasmine;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/jasmine-core/lib/jasmine-core/node_boot.js?");

/***/ }),

/***/ "./node_modules/jasmine/lib sync recursive":
/*!***************************************!*\
  !*** ./node_modules/jasmine/lib sync ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error('Cannot find module \"' + req + '\".');\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/jasmine/lib sync recursive\";\n\n//# sourceURL=webpack:///./node_modules/jasmine/lib_sync?");

/***/ }),

/***/ "./node_modules/jasmine/lib/filters/console_spec_filter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jasmine/lib/filters/console_spec_filter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = exports = ConsoleSpecFilter;\n\nfunction ConsoleSpecFilter(options) {\n  var filterString = options && options.filterString;\n  var filterPattern = new RegExp(filterString);\n\n  this.matches = function(specName) {\n    return filterPattern.test(specName);\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/jasmine/lib/filters/console_spec_filter.js?");

/***/ }),

/***/ "./node_modules/jasmine/lib/jasmine.js":
/*!*********************************************!*\
  !*** ./node_modules/jasmine/lib/jasmine.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\"),\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\"),\n    glob = __webpack_require__(/*! glob */ \"./node_modules/glob/glob.js\"),\n    CompletionReporter = __webpack_require__(/*! ./reporters/completion_reporter */ \"./node_modules/jasmine/lib/reporters/completion_reporter.js\"),\n    ConsoleSpecFilter = __webpack_require__(/*! ./filters/console_spec_filter */ \"./node_modules/jasmine/lib/filters/console_spec_filter.js\");\n\nmodule.exports = Jasmine;\nmodule.exports.ConsoleReporter = __webpack_require__(/*! ./reporters/console_reporter */ \"./node_modules/jasmine/lib/reporters/console_reporter.js\");\n\nfunction Jasmine(options) {\n  options = options || {};\n  var jasmineCore = options.jasmineCore || __webpack_require__(/*! jasmine-core */ \"./node_modules/jasmine-core/lib/jasmine-core.js\");\n  this.jasmineCorePath = path.join(jasmineCore.files.path, 'jasmine.js');\n  this.jasmine = jasmineCore.boot(jasmineCore);\n  this.projectBaseDir = options.projectBaseDir || path.resolve();\n  this.specDir = '';\n  this.specFiles = [];\n  this.helperFiles = [];\n  this.env = this.jasmine.getEnv({suppressLoadErrors: true});\n  this.reportersCount = 0;\n  this.completionReporter = new CompletionReporter();\n  this.onCompleteCallbackAdded = false;\n  this.exit = process.exit;\n  this.showingColors = true;\n  this.reporter = new module.exports.ConsoleReporter();\n  this.addReporter(this.reporter);\n  this.defaultReporterConfigured = false;\n\n  var jasmineRunner = this;\n  this.completionReporter.onComplete(function(passed) {\n    jasmineRunner.exitCodeCompletion(passed);\n  });\n  this.checkExit = checkExit(this);\n\n  this.coreVersion = function() {\n    return jasmineCore.version();\n  };\n}\n\nJasmine.prototype.randomizeTests = function(value) {\n  this.env.randomizeTests(value);\n};\n\nJasmine.prototype.seed = function(value) {\n  this.env.seed(value);\n};\n\nJasmine.prototype.showColors = function(value) {\n  this.showingColors = value;\n};\n\nJasmine.prototype.addSpecFile = function(filePath) {\n  this.specFiles.push(filePath);\n};\n\nJasmine.prototype.addReporter = function(reporter) {\n  this.env.addReporter(reporter);\n  this.reportersCount++;\n};\n\nJasmine.prototype.clearReporters = function() {\n  this.env.clearReporters();\n  this.reportersCount = 0;\n};\n\nJasmine.prototype.provideFallbackReporter = function(reporter) {\n  this.env.provideFallbackReporter(reporter);\n};\n\nJasmine.prototype.configureDefaultReporter = function(options) {\n  options.timer = options.timer || new this.jasmine.Timer();\n  options.print = options.print || function() {\n    process.stdout.write(util.format.apply(this, arguments));\n  };\n  options.showColors = options.hasOwnProperty('showColors') ? options.showColors : true;\n  options.jasmineCorePath = options.jasmineCorePath || this.jasmineCorePath;\n\n  this.reporter.setOptions(options);\n  this.defaultReporterConfigured = true;\n};\n\nJasmine.prototype.addMatchers = function(matchers) {\n  this.env.addMatchers(matchers);\n};\n\nJasmine.prototype.loadSpecs = function() {\n  this.specFiles.forEach(function(file) {\n    __webpack_require__(\"./node_modules/jasmine/lib sync recursive\")(file);\n  });\n};\n\nJasmine.prototype.loadHelpers = function() {\n  this.helperFiles.forEach(function(file) {\n    __webpack_require__(\"./node_modules/jasmine/lib sync recursive\")(file);\n  });\n};\n\nJasmine.prototype.loadConfigFile = function(configFilePath) {\n  try {\n    var absoluteConfigFilePath = path.resolve(this.projectBaseDir, configFilePath || 'spec/support/jasmine.json');\n    var config = __webpack_require__(\"./node_modules/jasmine/lib sync recursive\")(absoluteConfigFilePath);\n    this.loadConfig(config);\n  } catch (e) {\n    if(configFilePath || e.code != 'MODULE_NOT_FOUND') { throw e; }\n  }\n};\n\nJasmine.prototype.loadConfig = function(config) {\n  this.specDir = config.spec_dir || this.specDir;\n\n  if (config.stopSpecOnExpectationFailure !== undefined) {\n    this.env.throwOnExpectationFailure(config.stopSpecOnExpectationFailure);\n  }\n\n  if (config.stopOnSpecFailure !== undefined) {\n    this.env.stopOnSpecFailure(config.stopOnSpecFailure);\n  }\n\n  if (config.random !== undefined) {\n    this.env.randomizeTests(config.random);\n  }\n\n  if(config.helpers) {\n    this.addHelperFiles(config.helpers);\n  }\n\n  if(config.spec_files) {\n    this.addSpecFiles(config.spec_files);\n  }\n};\n\nJasmine.prototype.addHelperFiles = addFiles('helperFiles');\nJasmine.prototype.addSpecFiles = addFiles('specFiles');\n\nfunction addFiles(kind) {\n  return function (files) {\n    var jasmineRunner = this;\n    var fileArr = this[kind];\n\n    files.forEach(function(file) {\n      if(!(path.isAbsolute && path.isAbsolute(file))) {\n        file = path.join(jasmineRunner.projectBaseDir, jasmineRunner.specDir, file);\n      }\n      var filePaths = glob.sync(file);\n      filePaths.forEach(function(filePath) {\n        if(fileArr.indexOf(filePath) === -1) {\n          fileArr.push(filePath);\n        }\n      });\n    });\n  };\n}\n\nJasmine.prototype.onComplete = function(onCompleteCallback) {\n  this.completionReporter.onComplete(onCompleteCallback);\n};\n\nJasmine.prototype.stopSpecOnExpectationFailure = function(value) {\n  this.env.throwOnExpectationFailure(value);\n};\n\nJasmine.prototype.stopOnSpecFailure = function(value) {\n  this.env.stopOnSpecFailure(value);\n};\n\nJasmine.prototype.exitCodeCompletion = function(passed) {\n  if(passed) {\n    this.exit(0);\n  }\n  else {\n    this.exit(1);\n  }\n};\n\nvar checkExit = function(jasmineRunner) {\n  return function() {\n    if (!jasmineRunner.completionReporter.isComplete()) {\n      process.exitCode = 4;\n    }\n  };\n};\n\nJasmine.prototype.execute = function(files, filterString) {\n  process.on('exit', this.checkExit);\n\n  this.loadHelpers();\n  if (!this.defaultReporterConfigured) {\n    this.configureDefaultReporter({ showColors: this.showingColors });\n  }\n\n  if(filterString) {\n    var specFilter = new ConsoleSpecFilter({\n      filterString: filterString\n    });\n    this.env.specFilter = function(spec) {\n      return specFilter.matches(spec.getFullName());\n    };\n  }\n\n  if (files && files.length > 0) {\n    this.specDir = '';\n    this.specFiles = [];\n    this.addSpecFiles(files);\n  }\n\n  this.loadSpecs();\n\n  this.addReporter(this.completionReporter);\n  this.env.execute();\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/jasmine/lib/jasmine.js?");

/***/ }),

/***/ "./node_modules/jasmine/lib/reporters/completion_reporter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jasmine/lib/reporters/completion_reporter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n  var onCompleteCallback = function() {};\n  var completed = false;\n\n  this.onComplete = function(callback) {\n    onCompleteCallback = callback;\n  };\n\n  this.jasmineDone = function(result) {\n    completed = true;\n    onCompleteCallback(result.overallStatus === 'passed');\n  };\n\n  this.isComplete = function() {\n    return completed;\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/jasmine/lib/reporters/completion_reporter.js?");

/***/ }),

/***/ "./node_modules/jasmine/lib/reporters/console_reporter.js":
/*!****************************************************************!*\
  !*** ./node_modules/jasmine/lib/reporters/console_reporter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = exports = ConsoleReporter;\n\nvar noopTimer = {\n  start: function(){},\n  elapsed: function(){ return 0; }\n};\n\nfunction ConsoleReporter() {\n  var print = function() {},\n    showColors = false,\n    timer = noopTimer,\n    jasmineCorePath = null,\n    specCount,\n    executableSpecCount,\n    failureCount,\n    failedSpecs = [],\n    pendingSpecs = [],\n    ansi = {\n      green: '\\x1B[32m',\n      red: '\\x1B[31m',\n      yellow: '\\x1B[33m',\n      none: '\\x1B[0m'\n    },\n    failedSuites = [],\n    stackFilter = defaultStackFilter;\n\n  this.setOptions = function(options) {\n    if (options.print) {\n      print = options.print;\n    }\n    showColors = options.showColors || false;\n    if (options.timer) {\n      timer = options.timer;\n    }\n    if (options.jasmineCorePath) {\n      jasmineCorePath = options.jasmineCorePath;\n    }\n    if (options.stackFilter) {\n      stackFilter = options.stackFilter;\n    }\n  };\n\n  this.jasmineStarted = function(options) {\n    specCount = 0;\n    executableSpecCount = 0;\n    failureCount = 0;\n    if (options && options.order && options.order.random) {\n      print('Randomized with seed ' + options.order.seed);\n      printNewline();\n    }\n    print('Started');\n    printNewline();\n    timer.start();\n  };\n\n  this.jasmineDone = function(result) {\n    printNewline();\n    printNewline();\n    if(failedSpecs.length > 0) {\n      print('Failures:');\n    }\n    for (var i = 0; i < failedSpecs.length; i++) {\n      specFailureDetails(failedSpecs[i], i + 1);\n    }\n\n    for(i = 0; i < failedSuites.length; i++) {\n      suiteFailureDetails(failedSuites[i]);\n    }\n\n    if (result && result.failedExpectations && result.failedExpectations.length > 0) {\n      suiteFailureDetails(result);\n    }\n\n    if (pendingSpecs.length > 0) {\n      print(\"Pending:\");\n    }\n    for(i = 0; i < pendingSpecs.length; i++) {\n      pendingSpecDetails(pendingSpecs[i], i + 1);\n    }\n\n    if(specCount > 0) {\n      printNewline();\n\n      if(executableSpecCount !== specCount) {\n        print('Ran ' + executableSpecCount + ' of ' + specCount + plural(' spec', specCount));\n        printNewline();\n      }\n      var specCounts = executableSpecCount + ' ' + plural('spec', executableSpecCount) + ', ' +\n        failureCount + ' ' + plural('failure', failureCount);\n\n      if (pendingSpecs.length) {\n        specCounts += ', ' + pendingSpecs.length + ' pending ' + plural('spec', pendingSpecs.length);\n      }\n\n      print(specCounts);\n    } else {\n      print('No specs found');\n    }\n\n    printNewline();\n    var seconds = timer.elapsed() / 1000;\n    print('Finished in ' + seconds + ' ' + plural('second', seconds));\n    printNewline();\n\n    if (result && result.overallStatus === 'incomplete') {\n      print('Incomplete: ' + result.incompleteReason);\n      printNewline();\n    }\n\n    if (result && result.order && result.order.random) {\n      print('Randomized with seed ' + result.order.seed);\n      print(' (jasmine --random=true --seed=' + result.order.seed + ')');\n      printNewline();\n    }\n  };\n\n  this.specDone = function(result) {\n    specCount++;\n\n    if (result.status == 'pending') {\n      pendingSpecs.push(result);\n      executableSpecCount++;\n      print(colored('yellow', '*'));\n      return;\n    }\n\n    if (result.status == 'passed') {\n      executableSpecCount++;\n      print(colored('green', '.'));\n      return;\n    }\n\n    if (result.status == 'failed') {\n      failureCount++;\n      failedSpecs.push(result);\n      executableSpecCount++;\n      print(colored('red', 'F'));\n    }\n  };\n\n  this.suiteDone = function(result) {\n    if (result.failedExpectations && result.failedExpectations.length > 0) {\n      failureCount++;\n      failedSuites.push(result);\n    }\n  };\n\n  return this;\n\n  function printNewline() {\n    print('\\n');\n  }\n\n  function colored(color, str) {\n    return showColors ? (ansi[color] + str + ansi.none) : str;\n  }\n\n  function plural(str, count) {\n    return count == 1 ? str : str + 's';\n  }\n\n  function repeat(thing, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(thing);\n    }\n    return arr;\n  }\n\n  function indent(str, spaces) {\n    var lines = (str || '').split('\\n');\n    var newArr = [];\n    for (var i = 0; i < lines.length; i++) {\n      newArr.push(repeat(' ', spaces).join('') + lines[i]);\n    }\n    return newArr.join('\\n');\n  }\n\n  function defaultStackFilter(stack) {\n    if (!stack) {\n      return '';\n    }\n\n    var filteredStack = stack.split('\\n').filter(function(stackLine) {\n      return stackLine.indexOf(jasmineCorePath) === -1;\n    }).join('\\n');\n    return filteredStack;\n  }\n\n  function specFailureDetails(result, failedSpecNumber) {\n    printNewline();\n    print(failedSpecNumber + ') ');\n    print(result.fullName);\n    printFailedExpectations(result);\n  }\n\n  function suiteFailureDetails(result) {\n    printNewline();\n    print('Suite error: ' + result.fullName);\n    printFailedExpectations(result);\n  }\n\n  function printFailedExpectations(result) {\n    for (var i = 0; i < result.failedExpectations.length; i++) {\n      var failedExpectation = result.failedExpectations[i];\n      printNewline();\n      print(indent('Message:', 2));\n      printNewline();\n      print(colored('red', indent(failedExpectation.message, 4)));\n      printNewline();\n      print(indent('Stack:', 2));\n      printNewline();\n      print(indent(stackFilter(failedExpectation.stack), 4));\n    }\n\n    printNewline();\n  }\n\n  function pendingSpecDetails(result, pendingSpecNumber) {\n    printNewline();\n    printNewline();\n    print(pendingSpecNumber + ') ');\n    print(result.fullName);\n    printNewline();\n    var pendingReason = \"No reason given\";\n    if (result.pendingReason && result.pendingReason !== '') {\n      pendingReason = result.pendingReason;\n    }\n    print(indent(colored('yellow', pendingReason), 2));\n    printNewline();\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/jasmine/lib/reporters/console_reporter.js?");

/***/ }),

/***/ "./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(/*! brace-expansion */ \"./node_modules/brace-expansion/index.js\")\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n\n//# sourceURL=webpack:///./node_modules/minimatch/minimatch.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/mock/empty.js?");

/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\")\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n\n//# sourceURL=webpack:///./node_modules/once/once.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/path-is-absolute/index.js":
/*!************************************************!*\
  !*** ./node_modules/path-is-absolute/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-is-absolute/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/util/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack:///./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/util/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/wrappy/wrappy.js?");

/***/ }),

/***/ "./src/literalNumbers.en.js":
/*!**********************************!*\
  !*** ./src/literalNumbers.en.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar enConfig = {\n    'baseSeparator': '-',\n    'unitSeparator': 'and ',\n    'base': {\n        '0': 'zero',\n        '1': 'one',\n        '2': 'two',\n        '3': 'three',\n        '4': 'four',\n        '5': 'five',\n        '6': 'six',\n        '7': 'seven',\n        '8': 'eight',\n        '9': 'nine',\n        '10': 'ten',\n        '11': 'eleven',\n        '12': 'twelve',\n        '13': 'thirteen',\n        '14': 'fourteen',\n        '15': 'fifteen',\n        '16': 'sixteen',\n        '17': 'seventeen',\n        '18': 'eighteen',\n        '19': 'nineteen',\n        '20': 'twenty',\n        '30': 'thirty',\n        '40': 'forty',\n        '50': 'fifty',\n        '60': 'sixty',\n        '70': 'seventy',\n        '80': 'eighty',\n        '90': 'ninety'\n    },\n    'units': ['hundred', 'thousand', 'million', 'billion', 'trillion', 'quadrillion', 'quintillion'],\n    'unitExceptions': []\n};\nexports.default = enConfig;\n\n//# sourceURL=webpack:///./src/literalNumbers.en.js?");

/***/ }),

/***/ "./src/literalNumbers.he.js":
/*!**********************************!*\
  !*** ./src/literalNumbers.he.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar heConfig = {\n    'baseSeparator': ' ו',\n    'unitSeparator': 'ו',\n    'withAnd': true,\n    'base': {\n        '0': 'אפס',\n        '1': 'אחד',\n        '2': 'שניים',\n        '3': 'שלושה',\n        '4': 'ארבעה',\n        '5': 'חמישה',\n        '6': 'ששה',\n        '7': 'שבעה',\n        '8': 'שמונה',\n        '9': 'תשעה',\n        '10': 'עשרה',\n        '11': 'אחד עשר',\n        '12': 'שנים עשר',\n        '13': 'שלושה עשר',\n        '14': 'ארבעה עשר',\n        '15': 'חמשה עשר',\n        '16': 'ששה עשר',\n        '17': 'שבעה עשר',\n        '18': 'שמונה עשר',\n        '19': 'תשעה עשר',\n        '20': 'עשרים',\n        '30': 'שלושים',\n        '40': 'ארבעים',\n        '50': 'חמישים',\n        '60': 'ששים',\n        '70': 'שבעים',\n        '80': 'שמונים',\n        '90': 'תשעים',\n        '100': 'מאה',\n        '200': 'מאתיים',\n        '300': 'שלש מאות',\n        '400': 'ארבע מאות',\n        '500': 'חמש מאות',\n        '600': 'שש מאות',\n        '700': 'שבע מאות',\n        '800': 'שמונה מאות',\n        '900': 'תשע מאות',\n        '2000': 'אלפיים',\n        '3000': 'שלשת אלפים',\n        '4000': 'ארבעת אלפים',\n        '5000': 'חמשת אלפים',\n        '6000': 'ששת אלפים',\n        '7000': 'שבעת אלפים',\n        '8000': 'שמונת אלפים',\n        '9000': 'תשעת אלפים',\n        '10000': 'עשרת אלפים',\n        '100000': 'מאה אלף'\n    },\n    'units': [{\n        'singular': 'מאה',\n        'plural': 'מאות',\n        'avoidPrefixException': [1],\n        'useBaseInstead': true,\n        'useBaseException': []\n    }, {\n        'singular': 'אלף',\n        'useBaseUnits': [2, 3, 4, 5, 6, 7, 8, 9, 10],\n        'avoidPrefixException': [1]\n    }, {\n        'singular': 'מיליון',\n        'avoidPrefixException': [1],\n        'replacePrefixException': { '2': 'שני' }\n    }, {\n        'singular': 'מיליארד',\n        'avoidPrefixException': [1],\n        'replacePrefixException': { '2': 'שני' }\n    }, {\n        'singular': 'טריליון',\n        'avoidPrefixException': [1],\n        'replacePrefixException': { '2': 'שני' }\n    }],\n    'unitExceptions': {},\n    'grammticGenderExceptions': {\n        '1': 'אחת',\n        '2': 'שתיים',\n        '3': 'שלש',\n        '4': 'ארבע',\n        '5': 'חמש',\n        '6': 'שש',\n        '7': 'שבע',\n        '8': 'שמונה',\n        '9': 'תשע',\n        '10': 'עשר',\n        '11': 'אחת עשרה',\n        '12': 'שתים עשרה',\n        '13': 'שלש עשרה',\n        '14': 'ארבע עשרה',\n        '15': 'חמש עשרה',\n        '16': 'שש עשרה',\n        '17': 'שבע עשרה',\n        '18': 'שמונה עשרה',\n        '19': 'תשע עשרה'\n    }\n};\nexports.default = heConfig;\n\n//# sourceURL=webpack:///./src/literalNumbers.he.js?");

/***/ }),

/***/ "./src/literalNumbers.js":
/*!*******************************!*\
  !*** ./src/literalNumbers.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _literalNumbers = __webpack_require__(/*! ./literalNumbers.en */ \"./src/literalNumbers.en.js\");\n\nvar _literalNumbers2 = _interopRequireDefault(_literalNumbers);\n\nvar _literalNumbers3 = __webpack_require__(/*! ./literalNumbers.he */ \"./src/literalNumbers.he.js\");\n\nvar _literalNumbers4 = _interopRequireDefault(_literalNumbers3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n* @description collection of methods for adapting information to different languages and regional differences.\r\n* @module literalNumbers\r\n*/\nvar i18n = {\n    en: _literalNumbers2.default,\n    he: _literalNumbers4.default\n};\n\n//Only short scale is supported. For more details about short vs long scales\n// See https://en.wikipedia.org/wiki/Long_and_short_scales \nvar scale = [100];\nfor (var i = 1; i <= 6; i++) {\n    scale.push(Math.pow(10, i * 3));\n}\n\nvar defaults = {\n    noAnd: false,\n    lang: 'he'\n};\n\n/**\r\n * Converts numbers to their literal form. supports english and hebrew   \r\n * @method convertNumber    \r\n * @param {Number} number The number to convert\r\n * @param {Object} [options] An object representation of the options\r\n * options.lang - the language to wich the number should be translated.\r\n * possible values: 'he' - Hebrew (default) \r\n *                  'en' - English\r\n * @returns {String} the number in words (its literal representation)\r\n * @example Example usage. \r\n * literalNumbers.convertNumber(4323); //  '����� ����� ��� ���� ������ ������' \r\n * literalNumbers.convertNumber(4323,{lang:'en'}); //   'four thousand three hundred and twenty-three'\r\n */\n\nfunction convertNumber(number) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    function getLanguageDefinitions(options) {\n        var languageType = options.lang || '';\n        return i18n[languageType] ? i18n[languageType] : i18n[defaults.lang];\n    }\n\n    options = Object.assign(options, defaults);\n\n    var language = getLanguageDefinitions(options);\n\n    var baseCardinals = language.base;\n\n    function convert(currentNumber, options) {\n\n        function handleSmallerThan100(currentNumber, unit, baseCardinals) {\n            var dec = Math.floor(currentNumber / 10) * 10;\n            unit = currentNumber - dec;\n            if (unit) {\n                return baseCardinals[dec] + language.baseSeparator + convert(unit, options);\n            }\n            return baseCardinals[dec];\n        }\n\n        function tryGetBaseCardinal(number) {\n            if (options.useGrammticGenderException && language.grammticGenderExceptions && language.grammticGenderExceptions[number]) {\n                return language.grammticGenderExceptions[number];\n            }\n\n            if (language.unitExceptions[number]) {\n                return language.unitExceptions[number];\n            }\n\n            if (baseCardinals[number]) {\n                return baseCardinals[number];\n            }\n\n            return undefined;\n        }\n\n        currentNumber = Math.round(Number(currentNumber));\n        var unit;\n\n        var baseCardinal = tryGetBaseCardinal(currentNumber);\n\n        if (baseCardinal) {\n            return baseCardinal;\n        }\n\n        if (currentNumber < 100) {\n            return handleSmallerThan100(currentNumber, unit, baseCardinals);\n        }\n\n        var result = [];\n\n        function handleGreaterThan1000() {\n\n            function handleLeastSignificantNumbers(leastSignificantNumbers) {\n\n                if (leastSignificantNumbers) {\n                    if (options.noAnd && !(language.andException && language.andException[10])) {\n                        result.push(convert(leastSignificantNumbers, options));\n                    } else {\n                        result.push(language.unitSeparator + convert(leastSignificantNumbers, options));\n                    }\n                    //continue without the lease significant numbers\n                    currentNumber -= leastSignificantNumbers;\n                }\n            }\n\n            function shouldUseUnitBase(unit, number) {\n                return number && (unit.useBaseInstead && !unit.useBaseException.indexOf(number) > -1 || unit.useBaseUnits && unit.useBaseUnits.indexOf(number) > -1);\n            }\n\n            function calculateReminder(scaleIndex) {\n                var reminder = Math.floor(currentNumber / scale[scaleIndex]);\n                if (scaleIndex === 0) {\n                    return reminder % 10;\n                } else {\n                    return reminder % 1000;\n                }\n            }\n\n            function getUnitName(unit, reminder) {\n                if (typeof unit === 'string') {\n                    return unit;\n                } else {\n                    return reminder > 1 && unit.plural && !unit.avoidInNumberPlural ? unit.plural : unit.singular;\n                }\n            }\n\n            function convertUnit(unit, unitNumber, currentScale) {\n\n                function getUnitLiteralNumber() {\n                    var exception = language.unitExceptions[unitNumber];\n                    return exception || convert(unitNumber, Object.assign({\n                        // Languages with and exceptions need to set `noAnd` to false\n                        noAnd: !language.withAnd\n                    }, options));\n                }\n\n                function convertByUnitName(unit, unitNumber, result) {\n\n                    var unitName = getUnitName(unit, unitNumber);\n\n                    if (unit.avoidPrefixException && unit.avoidPrefixException.indexOf(unitNumber) > -1) {\n                        result.push(unitName);\n                    } else if (unit.replacePrefixException && unit.replacePrefixException.hasOwnProperty(unitNumber)) {\n                        result.push(unit.replacePrefixException[unitNumber] + ' ' + unitName);\n                    } else {\n                        var unitLiteralNumber = getUnitLiteralNumber(unitNumber);\n                        result.push(unitLiteralNumber + ' ' + unitName);\n                    }\n                }\n\n                if (!unitNumber) {\n                    return;\n                }\n\n                if (shouldUseUnitBase(unit, unitNumber)) {\n                    result.push(baseCardinals[unitNumber * currentScale]);\n                } else {\n                    convertByUnitName(unit, unitNumber, result);\n                }\n            }\n\n            var leastSignificantNumbers = currentNumber % 100;\n\n            handleLeastSignificantNumbers(leastSignificantNumbers);\n\n            for (var i = 0, len = language.units.length; i < len; i++) {\n                var reminder = calculateReminder(i);\n                convertUnit(language.units[i], reminder, scale[i]);\n            }\n        }\n\n        handleGreaterThan1000();\n\n        return result.reverse().join(' ');\n    }\n    // start the recursive conversion\n    return convert(number, options);\n}\n/* eslint-enable no-magic-numbers */\nvar literalNumbers = {\n    convertNumber: convertNumber,\n    defaults: defaults\n};\n\nexports.default = literalNumbers;\n\n//# sourceURL=webpack:///./src/literalNumbers.js?");

/***/ }),

/***/ "./test/literalNumbers.spec.js":
/*!*************************************!*\
  !*** ./test/literalNumbers.spec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _jasmine = __webpack_require__(/*! jasmine */ \"./node_modules/jasmine/lib/jasmine.js\");\n\nvar _jasmine2 = _interopRequireDefault(_jasmine);\n\nvar _literalNumbers = __webpack_require__(/*! ../src/literalNumbers */ \"./src/literalNumbers.js\");\n\nvar _literalNumbers2 = _interopRequireDefault(_literalNumbers);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable no-magic-numbers */\ndescribe('literal numbers', function () {\n    describe('english literal numbers', function () {\n\n        it('defined', function () {\n            expect(typeof _literalNumbers2.default === 'undefined' ? 'undefined' : _typeof(_literalNumbers2.default)).toEqual('object');\n            expect(_typeof(_literalNumbers2.default.convertNumber)).toEqual('function');\n        });\n\n        it('doesn\\'t blow up weirdly with invalid input', function () {\n            expect(_literalNumbers2.default.convertNumber('asdfasdfasdf', { lang: 'en' })).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('0.as', { lang: 'en' })).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('0.123', { lang: 'en' })).toEqual('zero');\n            expect(_literalNumbers2.default.convertNumber('0.8', { lang: 'en' })).toEqual('one');\n            expect(_literalNumbers2.default.convertNumber('2.8', { lang: 'en' })).toEqual('three');\n            expect(_literalNumbers2.default.convertNumber('asdf.8', { lang: 'en' })).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('120391938123..', { lang: 'en' })).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('1000000000.123', { lang: 'en' })).toEqual('one billion');\n            expect(_literalNumbers2.default.convertNumber('1/3', { lang: 'en' })).toEqual('');\n            expect(_literalNumbers2.default.convertNumber(1 / 3, { lang: 'en' })).toEqual('zero');\n            expect(_literalNumbers2.default.convertNumber('1/2', { lang: 'en' })).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('1.123/2', { lang: 'en' })).toEqual('');\n        });\n\n        it('correctly converts numbers < 10', function () {\n            expect(_literalNumbers2.default.convertNumber(1000000000, { lang: 'en' })).toEqual('one billion');\n            expect(_literalNumbers2.default.convertNumber(3, { lang: 'en' })).toEqual('three');\n            expect(_literalNumbers2.default.convertNumber(8, { lang: 'en' })).toEqual('eight');\n        });\n\n        it('correctly converts numbers < 20', function () {\n            expect(_literalNumbers2.default.convertNumber(13, { lang: 'en' })).toEqual('thirteen');\n            expect(_literalNumbers2.default.convertNumber(19, { lang: 'en' })).toEqual('nineteen');\n        });\n\n        it('correctly converts numbers < 100', function () {\n            expect(_literalNumbers2.default.convertNumber(20, { lang: 'en' })).toEqual('twenty');\n            expect(_literalNumbers2.default.convertNumber(25, { lang: 'en' })).toEqual('twenty-five');\n            expect(_literalNumbers2.default.convertNumber(88, { lang: 'en' })).toEqual('eighty-eight');\n            expect(_literalNumbers2.default.convertNumber(73, { lang: 'en' })).toEqual('seventy-three');\n        });\n\n        it('correctly converts numbers < 1000', function () {\n            expect(_literalNumbers2.default.convertNumber(200, { lang: 'en' })).toEqual('two hundred');\n            expect(_literalNumbers2.default.convertNumber(242, { lang: 'en' })).toEqual('two hundred and forty-two');\n            expect(_literalNumbers2.default.convertNumber(1234, { lang: 'en' })).toEqual('one thousand two hundred and thirty-four');\n            expect(_literalNumbers2.default.convertNumber(4323, { lang: 'en' })).toEqual('four thousand three hundred and twenty-three');\n        });\n\n        it('correctly converts numbers > 1000', function () {\n            expect(_literalNumbers2.default.convertNumber(4323000, { lang: 'en' })).toEqual('four million three hundred twenty-three thousand');\n            expect(_literalNumbers2.default.convertNumber(4323055, { lang: 'en' })).toEqual('four million three hundred twenty-three thousand and fifty-five');\n            expect(_literalNumbers2.default.convertNumber(1570025, { lang: 'en' })).toEqual('one million five hundred seventy thousand and twenty-five');\n        });\n\n        it('correctly converts numbers > 1 000 000 000', function () {\n            expect(_literalNumbers2.default.convertNumber(1000000000, { lang: 'en' })).toEqual('one billion');\n            expect(_literalNumbers2.default.convertNumber(2580000000, { lang: 'en' })).toEqual('two billion five hundred eighty million');\n            expect(_literalNumbers2.default.convertNumber(1000000000000, { lang: 'en' })).toEqual('one trillion');\n            expect(_literalNumbers2.default.convertNumber(3627000000000, { lang: 'en' })).toEqual('three trillion six hundred twenty-seven billion');\n        });\n    });\n\n    describe('hebrew literal numbers', function () {\n\n        it('defined', function () {\n            expect(typeof _literalNumbers2.default === 'undefined' ? 'undefined' : _typeof(_literalNumbers2.default)).toEqual('object');\n            expect(_typeof(_literalNumbers2.default.convertNumber)).toEqual('function');\n        });\n\n        it('doesn\\'t blow up weirdly with invalid input', function () {\n            expect(_literalNumbers2.default.convertNumber('asdfasdfasdf')).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('0.as')).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('0.123')).toEqual('אפס');\n            expect(_literalNumbers2.default.convertNumber('0.8')).toEqual('אחד');\n            expect(_literalNumbers2.default.convertNumber('2.8')).toEqual('שלושה');\n            expect(_literalNumbers2.default.convertNumber('asdf.8')).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('120391938123..')).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('1000000000.123')).toEqual('מיליארד');\n            expect(_literalNumbers2.default.convertNumber('1/3')).toEqual('');\n            expect(_literalNumbers2.default.convertNumber(1 / 3)).toEqual('אפס');\n            expect(_literalNumbers2.default.convertNumber('1/2')).toEqual('');\n            expect(_literalNumbers2.default.convertNumber('1.123/2')).toEqual('');\n        });\n\n        it('correctly converts numbers < 10', function () {\n            expect(_literalNumbers2.default.convertNumber(3)).toEqual('שלושה');\n            expect(_literalNumbers2.default.convertNumber(8)).toEqual('שמונה');\n        });\n\n        it('correctly converts numbers < 20', function () {\n            expect(_literalNumbers2.default.convertNumber(13)).toEqual('שלושה עשר');\n            expect(_literalNumbers2.default.convertNumber(19)).toEqual('תשעה עשר');\n        });\n\n        it('correctly converts numbers < 100', function () {\n            expect(_literalNumbers2.default.convertNumber(20)).toEqual('עשרים');\n            expect(_literalNumbers2.default.convertNumber(25)).toEqual('עשרים וחמישה');\n            expect(_literalNumbers2.default.convertNumber(88)).toEqual('שמונים ושמונה');\n            expect(_literalNumbers2.default.convertNumber(73)).toEqual('שבעים ושלושה');\n        });\n\n        it('correctly converts numbers < 100 with grammatic gender exception', function () {\n            expect(_literalNumbers2.default.convertNumber(10, { useGrammticGenderException: true })).toEqual('עשר');\n            expect(_literalNumbers2.default.convertNumber(25, { useGrammticGenderException: true })).toEqual('עשרים וחמש');\n            expect(_literalNumbers2.default.convertNumber(3, { useGrammticGenderException: true })).toEqual('שלש');\n            expect(_literalNumbers2.default.convertNumber(16, { useGrammticGenderException: true })).toEqual('שש עשרה');\n        });\n\n        it('correctly converts numbers < 1000', function () {\n            expect(_literalNumbers2.default.convertNumber(200)).toEqual('מאתיים');\n            expect(_literalNumbers2.default.convertNumber(242)).toEqual('מאתיים וארבעים ושניים');\n            expect(_literalNumbers2.default.convertNumber(1234)).toEqual('אלף מאתיים ושלושים וארבעה');\n            expect(_literalNumbers2.default.convertNumber(4323)).toEqual('ארבעת אלפים שלש מאות ועשרים ושלושה');\n        });\n\n        it('correctly converts numbers > 1000', function () {\n            expect(_literalNumbers2.default.convertNumber(103000)).toEqual('מאה ושלושה אלף');\n\n            expect(_literalNumbers2.default.convertNumber(4323000)).toEqual('ארבעה מיליון שלש מאות ועשרים ושלושה אלף');\n            expect(_literalNumbers2.default.convertNumber(2323055)).toEqual('שני מיליון שלש מאות ועשרים ושלושה אלף וחמישים וחמישה');\n            expect(_literalNumbers2.default.convertNumber(1570025)).toEqual('מיליון חמש מאות ושבעים אלף ועשרים וחמישה');\n        });\n\n        it('correctly converts numbers > 1 000 000 ', function () {\n            expect(_literalNumbers2.default.convertNumber(1000000000)).toEqual('מיליארד');\n            expect(_literalNumbers2.default.convertNumber(2580000000)).toEqual('שני מיליארד חמש מאות ושמונים מיליון');\n            expect(_literalNumbers2.default.convertNumber(1000000000000)).toEqual('טריליון');\n            expect(_literalNumbers2.default.convertNumber(3627000000000)).toEqual('שלושה טריליון שש מאות ועשרים ושבעה מיליארד');\n        });\n    });\n});\n/* eslint-enable no-magic-numbers */\n\n//# sourceURL=webpack:///./test/literalNumbers.spec.js?");

/***/ })

/******/ });